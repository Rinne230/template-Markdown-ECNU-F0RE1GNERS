#  杂项

## 线性基

+ 线性基模板(总异或最大值)

```cpp
ll p[64];
void insert(ll x){
    for (int i = 63; ~i; --i){
        if (!(x >> i)) continue;
        if (!p[i]){
            p[i] = x;
            break;
        }
        x ^= p[i];
    }
}
```

+ 区间线性基(区间异或最大值,强制在线)

```cpp
#include<bits/stdc++.h>
#define M 500009
using namespace std;
int read() {
	int f = 1, re = 0; char ch;
	for (ch = getchar(); !isdigit(ch) && ch != '-'; ch = getchar());
	if (ch == '-') {f = -1, ch = getchar();}
	for (; isdigit(ch); ch = getchar()) re = (re << 3) + (re << 1) + ch - '0';
	return re * f;
}
int pos[M][32], p[M][32], t, n, m, lastans;
void insert(int val, int num, int po) {
	for (int i = 30; i >= 0; i--) {
		if (val & (1ll << i)) {
			if (!p[num][i]) {p[num][i] = val, pos[num][i] = po; return;}
			else if (pos[num][i] < po) {
				swap(val, p[num][i]);
				swap(po, pos[num][i]);
			} val ^= p[num][i];
		}
	} return;
}
int query(int l, int r) {
	int ans = 0;
	for (int i = 30; i >= 0; i--)
		if (pos[r][i] >= l && (p[r][i]^ans) > ans) ans ^= p[r][i];
	return ans;
}
signed main() {
	t = read();
	while (t--) {
		n = read(), m = read(); lastans = 0;
		memset(p, 0, sizeof(p));
		memset(pos, 0, sizeof(pos));
		for (int i = 1; i <= n; i++) {
			int x = read();
			for (int j = 0; j <= 30; j++)
				p[i][j] = p[i - 1][j], pos[i][j] = pos[i - 1][j];
			insert(x, i, i);
		}
		for (int i = 1; i <= m; i++) {
			int opt = read();
			if (opt) {
				int x = read()^lastans; n++;
				for (int j = 0; j <= 30; j++)
					p[n][j] = p[n - 1][j], pos[n][j] = pos[n - 1][j];
				insert(x, n, n);
			}
			else {
				int l = (read()^lastans) % n + 1;
				int r = (read()^lastans) % n + 1;
				if (l > r) swap(l, r);
				printf("%d\n", lastans = query(l, r));
			}
		}
	} return 0;
}
```


+ 区间问题(异或和,区间内是否存在异或和为x)

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
constexpr ll maxn = 4e5 + 5;
int pos[65];
ll p[65], t, n, m;
bool ans[maxn];
void insert(ll val, int P)
{
    for (int i = 59; i >= 0; i--)
    {
        if (val & (1ll << i))
        {
            if (!p[i])
            {
                p[i] = val, pos[i] = P;
                return;
            }
            else if (pos[i] < P)
            {
                swap(val, p[i]);
                swap(P, pos[i]);
            }
            val ^= p[i];
        }
    }
    return;
}
bool query(int l, ll val)
{
    for (int i = 59; i >= 0; i--)
    {
        if (val & (1ll << i))
        {
            if (!p[i])
                return false;
            if (pos[i] < l)
                return false;
            val ^= p[i];
        }
    }
    return true;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    vector<ll> a(n + 1);
    vector<tuple<int, int, ll, int>> q(m);
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++)
    {
        auto &[l, r, val, id] = q[i];
        cin >> l >> r >> val, id = i;
    }
    sort(q.begin(), q.end(), [&](auto x, auto y)
         {
        auto &[l1,r1,val1,id1] = x;
        auto &[l2,r2,val2,id2] = y;
        return (r1==r2)?(l1<l2):(r1<r2); });
    int R = 0;
    for (int i = 0; i < m; i++)
    {
        auto &[l, r, val, id] = q[i];
        while (R < r)
            insert(a[R + 1], R + 1),R++;
        ans[id] = query(l, val);
    }
    for (int i = 0; i < m; i++)
    {
        cout << (ans[i] ? "Yes\n" : "No\n");
    }

    return 0;
}

```

## Tarjan

+ 缩点

```cpp
//Tarjan缩点（删去一个点，有多少点对不能互通）
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define x first
#define y second
#define int ll
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
typedef __int128 i128;
const ll maxn = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

ll n, m;
ll head[maxn], nxt[maxn], to[maxn], tot = 1;
ll dfn[maxn], low[maxn];
bool vis[maxn];
ll cnt;
ll deg[maxn];
ll ans[maxn];
ll sz[maxn];

void addedge(int u, int v)
{
    nxt[++tot] = head[u];
    to[head[u] = tot] = v;
    nxt[++tot] = head[v];
    to[head[v] = tot] = u;
}

void tarjan(int u, int lst)
{
    dfn[u] = low[u] = ++cnt;
    ll sum = 0;
    sz[u] = 1;
    for (int i = head[u]; i; i = nxt[i])
    {
        if (i != (lst ^ 1))
        {
            int v = to[i];
            if (!dfn[v])
            {
                tarjan(v, i);
                sz[u] += sz[v];
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u])
                {
                    // 找到新的双连通分量
                    ans[u] += 1ll * sz[v] * (n - sz[v]);
                    sum += sz[v];
                    ++deg[u];
                    if (deg[u] > 1 || u != 1)
                        vis[u] = 1;
                }
            }
            else
                low[u] = min(low[u], dfn[v]);
        }
    }
    if (vis[u])
    {
        ans[u] += 1ll * (n - (sum + 1)) * (sum + 1) + n - 1;
    }else
        ans[u] = 2 * (n - 1);
}
void solve()
{
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        addedge(u, v);
    }
    tarjan(1, -1);
    for (int i = 1; i <= n; ++i)
    {
        if (vis[i])
        {
            cout << ans[i] << endl;
        }
        else
        {
            cout << 2ll * (n - 1) << endl;
        }
    }
}

signed main()
{
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("res.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }

    return 0;
}
```

## 位运算基础

```cpp
去掉最后一位
x >> 1
在最后一位加个0
x << 1
在最后一位加个1
(x << 1) | 1
把最后一位变成1
x | 1
把最后一位变成0
(x | 1) – 1
最后一位取反
x ^ 1
把右数第k位变成1
x | (1 << (k – 1))
把右数第k位变成0
x & (~(1 << (k – 1)))
右数第k位取反
x ^ ( 1 << (k – 1))
取末k位
x & ((1 << k) – 1)
取右数第k位
(x >> (k – 1)) & 1
把末k位变成1
x | ((1 << k) – 1)
把右边连续的1变成0
x & (x + 1)
把右边第一个0变成1
x | (x + 1)
取右边连续的1
(x ^ (x + 1)) >> 1
去掉右起第一个1的左边
x & (-x)
```

## 虚拟源点

+ 843div2D

给定n个点，每个点的权值为ai。两个位置i, j存在一个长度为1的边当且仅当gcd(ai, aj) > 1。求S到T的最短路

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 6e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int prime[maxn], cnt = 0;
bool vis[maxn];
int minp[maxn];
int idx[maxn];

void init(int n) {
	for (int i = 2; i <= n; ++i) {
		if (vis[i] == false) {
			prime[++cnt] = i;
			minp[i] = i;
			idx[i] = cnt;
		}
		for (int j = 1; j <= cnt && i * prime[j] <= n; ++j) {
			minp[i * prime[j]] = prime[j];
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) break;
		}
	}
}

int a[maxn];
set<int> e[maxn];
ll dis[maxn];
priority_queue<pair<int, int>> q;
int vs[maxn], pre[maxn];

void dij(int s, int exn, int n) {
	rep(i, 1, exn) dis[i] = 1e18;
	dis[s] = 0;
	q.push({0, s});
	while (!q.empty()) {
		pair<int, int> cur = q.top();
		q.pop();
		if (vs[cur.y]) continue;
		int u = cur.y;
		vs[u] = 1;
		for (auto v : e[u]) {
			int w = 1;
			if (v > n) w = 0;
			if (dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
				pre[v] = u;
				if (!vs[v]) q.push({ -dis[v], 	v});
			}
		}
	}
}

void solve() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	int s, t;
	cin >> s >> t;
	int exn = n;
	for (int i = 1; i <= n; ++i) {
		int tmp = a[i];
		while (tmp > 1) {
			int tar = idx[minp[tmp]];
			exn = max(exn, n + tar);
			e[n + tar].insert(i);
			e[i].insert(n + tar);
			tmp /= minp[tmp];
		}
	}
	dij(s, exn, n);
	if (dis[t] == 1e18) cout << -1 << endl;
	else {
		vector<int> ans;
		int tmp = t;
		while (tmp != s && tmp != 0) {
			if (tmp <= n) ans.push_back(tmp);
			tmp = pre[tmp];
		}
		ans.push_back(s);
		reverse(ans.begin(), ans.end());
		cout << ans.size() << endl;
		for (auto it : ans) cout << it << " " ;
		cout << endl;
	}
}
int main() {
	ios;
	init(3e5 + 10);
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```
