#  杂项

## 线性基

+ 线性基模板(总异或最大值)

```cpp
ll p[64];
void insert(ll x){
    for (int i = 63; ~i; --i){
        if (!(x >> i)) continue;
        if (!p[i]){
            p[i] = x;
            break;
        }
        x ^= p[i];
    }
}
```

+ 区间线性基(区间异或最大值,强制在线)

```cpp
#include<bits/stdc++.h>
#define M 500009
using namespace std;
int read() {
	int f = 1, re = 0; char ch;
	for (ch = getchar(); !isdigit(ch) && ch != '-'; ch = getchar());
	if (ch == '-') {f = -1, ch = getchar();}
	for (; isdigit(ch); ch = getchar()) re = (re << 3) + (re << 1) + ch - '0';
	return re * f;
}
int pos[M][32], p[M][32], t, n, m, lastans;
void insert(int val, int num, int po) {
	for (int i = 30; i >= 0; i--) {
		if (val & (1ll << i)) {
			if (!p[num][i]) {p[num][i] = val, pos[num][i] = po; return;}
			else if (pos[num][i] < po) {
				swap(val, p[num][i]);
				swap(po, pos[num][i]);
			} val ^= p[num][i];
		}
	} return;
}
int query(int l, int r) {
	int ans = 0;
	for (int i = 30; i >= 0; i--)
		if (pos[r][i] >= l && (p[r][i]^ans) > ans) ans ^= p[r][i];
	return ans;
}
signed main() {
	t = read();
	while (t--) {
		n = read(), m = read(); lastans = 0;
		memset(p, 0, sizeof(p));
		memset(pos, 0, sizeof(pos));
		for (int i = 1; i <= n; i++) {
			int x = read();
			for (int j = 0; j <= 30; j++)
				p[i][j] = p[i - 1][j], pos[i][j] = pos[i - 1][j];
			insert(x, i, i);
		}
		for (int i = 1; i <= m; i++) {
			int opt = read();
			if (opt) {
				int x = read()^lastans; n++;
				for (int j = 0; j <= 30; j++)
					p[n][j] = p[n - 1][j], pos[n][j] = pos[n - 1][j];
				insert(x, n, n);
			}
			else {
				int l = (read()^lastans) % n + 1;
				int r = (read()^lastans) % n + 1;
				if (l > r) swap(l, r);
				printf("%d\n", lastans = query(l, r));
			}
		}
	} return 0;
}
```


+ 区间问题(异或和,区间内是否存在异或和为x)

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
constexpr ll maxn = 4e5 + 5;
int pos[65];
ll p[65], t, n, m;
bool ans[maxn];
void insert(ll val, int P)
{
    for (int i = 59; i >= 0; i--)
    {
        if (val & (1ll << i))
        {
            if (!p[i])
            {
                p[i] = val, pos[i] = P;
                return;
            }
            else if (pos[i] < P)
            {
                swap(val, p[i]);
                swap(P, pos[i]);
            }
            val ^= p[i];
        }
    }
    return;
}
bool query(int l, ll val)
{
    for (int i = 59; i >= 0; i--)
    {
        if (val & (1ll << i))
        {
            if (!p[i])
                return false;
            if (pos[i] < l)
                return false;
            val ^= p[i];
        }
    }
    return true;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    vector<ll> a(n + 1);
    vector<tuple<int, int, ll, int>> q(m);
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++)
    {
        auto &[l, r, val, id] = q[i];
        cin >> l >> r >> val, id = i;
    }
    sort(q.begin(), q.end(), [&](auto x, auto y)
         {
        auto &[l1,r1,val1,id1] = x;
        auto &[l2,r2,val2,id2] = y;
        return (r1==r2)?(l1<l2):(r1<r2); });
    int R = 0;
    for (int i = 0; i < m; i++)
    {
        auto &[l, r, val, id] = q[i];
        while (R < r)
            insert(a[R + 1], R + 1),R++;
        ans[id] = query(l, val);
    }
    for (int i = 0; i < m; i++)
    {
        cout << (ans[i] ? "Yes\n" : "No\n");
    }

    return 0;
}

```

## Tarjan

+ 缩点

```cpp
//Tarjan缩点（删去一个点，有多少点对不能互通）
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define x first
#define y second
#define int ll
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
typedef __int128 i128;
const ll maxn = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

ll n, m;
ll head[maxn], nxt[maxn], to[maxn], tot = 1;
ll dfn[maxn], low[maxn];
bool vis[maxn];
ll cnt;
ll deg[maxn];
ll ans[maxn];
ll sz[maxn];

void addedge(int u, int v)
{
    nxt[++tot] = head[u];
    to[head[u] = tot] = v;
    nxt[++tot] = head[v];
    to[head[v] = tot] = u;
}

void tarjan(int u, int lst)
{
    dfn[u] = low[u] = ++cnt;
    ll sum = 0;
    sz[u] = 1;
    for (int i = head[u]; i; i = nxt[i])
    {
        if (i != (lst ^ 1))
        {
            int v = to[i];
            if (!dfn[v])
            {
                tarjan(v, i);
                sz[u] += sz[v];
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u])
                {
                    // 找到新的双连通分量
                    ans[u] += 1ll * sz[v] * (n - sz[v]);
                    sum += sz[v];
                    ++deg[u];
                    if (deg[u] > 1 || u != 1)
                        vis[u] = 1;
                }
            }
            else
                low[u] = min(low[u], dfn[v]);
        }
    }
    if (vis[u])
    {
        ans[u] += 1ll * (n - (sum + 1)) * (sum + 1) + n - 1;
    }else
        ans[u] = 2 * (n - 1);
}
void solve()
{
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        addedge(u, v);
    }
    tarjan(1, -1);
    for (int i = 1; i <= n; ++i)
    {
        if (vis[i])
        {
            cout << ans[i] << endl;
        }
        else
        {
            cout << 2ll * (n - 1) << endl;
        }
    }
}

signed main()
{
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("res.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }

    return 0;
}
```

## 位运算基础

```cpp
去掉最后一位
x >> 1
在最后一位加个0
x << 1
在最后一位加个1
(x << 1) | 1
把最后一位变成1
x | 1
把最后一位变成0
(x | 1) – 1
最后一位取反
x ^ 1
把右数第k位变成1
x | (1 << (k – 1))
把右数第k位变成0
x & (~(1 << (k – 1)))
右数第k位取反
x ^ ( 1 << (k – 1))
取末k位
x & ((1 << k) – 1)
取右数第k位
(x >> (k – 1)) & 1
把末k位变成1
x | ((1 << k) – 1)
把右边连续的1变成0
x & (x + 1)
把右边第一个0变成1
x | (x + 1)
取右边连续的1
(x ^ (x + 1)) >> 1
去掉右起第一个1的左边
x & (-x)
```

## 虚拟源点

+ 843div2D

给定n个点，每个点的权值为ai。两个位置i, j存在一个长度为1的边当且仅当gcd(ai, aj) > 1。求S到T的最短路

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 6e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int prime[maxn], cnt = 0;
bool vis[maxn];
int minp[maxn];
int idx[maxn];

void init(int n) {
	for (int i = 2; i <= n; ++i) {
		if (vis[i] == false) {
			prime[++cnt] = i;
			minp[i] = i;
			idx[i] = cnt;
		}
		for (int j = 1; j <= cnt && i * prime[j] <= n; ++j) {
			minp[i * prime[j]] = prime[j];
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) break;
		}
	}
}

int a[maxn];
set<int> e[maxn];
ll dis[maxn];
priority_queue<pair<int, int>> q;
int vs[maxn], pre[maxn];

void dij(int s, int exn, int n) {
	rep(i, 1, exn) dis[i] = 1e18;
	dis[s] = 0;
	q.push({0, s});
	while (!q.empty()) {
		pair<int, int> cur = q.top();
		q.pop();
		if (vs[cur.y]) continue;
		int u = cur.y;
		vs[u] = 1;
		for (auto v : e[u]) {
			int w = 1;
			if (v > n) w = 0;
			if (dis[v] > dis[u] + w) {
				dis[v] = dis[u] + w;
				pre[v] = u;
				if (!vs[v]) q.push({ -dis[v], 	v});
			}
		}
	}
}

void solve() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	int s, t;
	cin >> s >> t;
	int exn = n;
	for (int i = 1; i <= n; ++i) {
		int tmp = a[i];
		while (tmp > 1) {
			int tar = idx[minp[tmp]];
			exn = max(exn, n + tar);
			e[n + tar].insert(i);
			e[i].insert(n + tar);
			tmp /= minp[tmp];
		}
	}
	dij(s, exn, n);
	if (dis[t] == 1e18) cout << -1 << endl;
	else {
		vector<int> ans;
		int tmp = t;
		while (tmp != s && tmp != 0) {
			if (tmp <= n) ans.push_back(tmp);
			tmp = pre[tmp];
		}
		ans.push_back(s);
		reverse(ans.begin(), ans.end());
		cout << ans.size() << endl;
		for (auto it : ans) cout << it << " " ;
		cout << endl;
	}
}
int main() {
	ios;
	init(3e5 + 10);
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```

## 简单环

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MOD = 998244353;
const int maxn = 25;
ll ans[maxn], dp[1 << 20][maxn], num[1 << 20];
int n, m, k;
bool vis[maxn][maxn];
ll ksm(ll a, ll b)
{
    if (b == 0)
        return 1;
    if (b == 1)
        return a % MOD;
    ll mid = ksm(a, b >> 1);
    if (b & 1)
        return mid * mid % MOD * a % MOD;
    else
        return mid * mid % MOD;
}
void Init()
{
    for (int st = 0; st < (1 << n); st++)
    {
        int cur = st, cnt = 0;
        while (cur)
        {
            if (cur & 1)
                cnt++;
            cur >>= 1;
        }
        num[st] = cnt;
    }
}
int main()
{
    scanf("%d%d%d", &n, &m, &k);
    Init();
    for (int i = 1; i <= m; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        vis[u][v] = true, vis[v][u] = true;
    }
    for (int i = 1; i <= n; i++)
        dp[1 << (i - 1)][i] = 1;
    for (int st = 1; st < (1 << n); st++)
    {
        int lowbit = st & (-st), s = 0;
        while (lowbit)
            s++, lowbit >>= 1;
        for (int j = 1; j <= n; j++)
            if (dp[st][j])
            {
                if (vis[j][s] && num[st] > 2)
                    ans[num[st] % k] = (ans[num[st] % k] + dp[st][j]) % MOD;
                for (int k = s + 1; k <= n; k++)
                    if ((st & (1 << (k - 1))) == 0 && vis[j][k])
                    {
                        int p = st | (1 << (k - 1));
                        dp[p][k] = (dp[p][k] + dp[st][j]) % MOD;
                    }
            }
    }
    ll invtwo = ksm(2, MOD - 2);
    for (int i = 1; i <= k; i++)
        cout << ans[i - 1] * invtwo % MOD << endl;
    return 0;
}
```

## 数位dp

```cpp
/*
 * 第一行,一个整数T,代表数据组数对于每组数据,
 * 有三个数字 l,r,n
 * 接下来n行，每行一个数字x，接下来一个数len表示数字x在数字串中连续出现的次数不能大于len
 * 对于每组数据
 * 输出一个整数,表示l,r中满足约束的数字个数。(对20020219取模)
 */
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 20;
const ll mod = 20020219;
ll len[maxn];
ll a[maxn];
ll f[maxn][maxn][maxn];
ll l, r, n;

void solve()
{
    // flag表示是否能直接返回值，也就是说前pos-1位与原数是否不同
    // 相同则这一位收到限制需要继续递归求解
    // 不同则不受限制，如果之前算过了可以直接返回
    function<ll(ll, ll, ll, bool)> dp = [&](ll pos, ll x, ll cnt, bool flag)
    {
        if (pos == 0)
            return 1ll;
        if (flag && f[pos][x][cnt])
            return f[pos][x][cnt];
        int up = flag ? 9 : a[pos];
        ll ans = 0;
        for (int i = 0; i <= up; ++i)
        {
            if (i == x)
            {
                if (cnt + 1 > len[i])
                    continue;
                ans = (ans + dp(pos - 1, i, cnt + 1, flag || (i < up))) % mod;
            }
            else
            {
                ans = (ans + dp(pos - 1, i, 1, flag || (i < up))) % mod;
            }
        }
        if (flag)
            f[pos][x][cnt] = ans % mod;
        return ans % mod;
    };
    function<ll(ll)> clac = [&](ll x)
    {
        int id = 0;
        while (x)
        {
            a[++id] = x % 10;
            x /= 10;
        }
        return dp(id, 0, 0, 0);
    };

    cin >> l >> r >> n;
    memset(len, 0x3f, sizeof(len));
    memset(f, 0, sizeof(f));
    for (int i = 1; i <= n; i++)
    {
        ll x, cnt;
        cin >> x >> cnt;
        len[x] = min(len[x], cnt);
    }
    cout << (clac(r) - clac(l - 1) + mod) % mod << "\n";
}

int main()
{
    ios;
    int t = 1;
    cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

## 很多线段树，树状数组

```cpp
//线段树单点修改，区间查询
void build(int u, int l, int r)
{
    tr[u] = {l, r};
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(u << 1, l, mid);
    build(u << 1 | 1, mid + 1, r);
}
//modify(1, position, valuse)
void modify(int u, int x, int v){
    if (tr[u].l == tr[u].r)
    {
        tr[u].v = v;
        return;
    }
    int mid = (tr[u].l + tr[u].r) >> 1;
    if (x <= mid)
    {
        modify(u << 1, x, v);
    }
    else
    {
        modify(u << 1 | 1, x, v);
    }
    tr[u].v = max(tr[u << 1].v, tr[u << 1 | 1].v);
}
//query(1, l, r)
int query(int u, int l, int r)
{
    if (l <= tr[u].l && r >= tr[u].r)
    {
        return tr[u].v;
    }

    int mid = (tr[u].l + tr[u].r) >> 1;
    int a = 0;
    int b = 0;
    if (l <= mid)
    {
        a = query(u << 1, l, r);
    }
    if (r > mid)
    {
        b = query(u << 1 | 1, l, r);
    }
    return max(a, b);
}

//线段树区间加，区间查询
ll a[maxn], w[maxn * 4], lazyTag[maxn * 4];
void pushup(int u) { w[u] = w[u << 1] + w[u << 1 | 1]; } // 上推
void makeTag(int u, int len, ll x)
{ // 下放lazytag
    lazyTag[u] += x;
    w[u] += len * x;
}
void pushdown(int u, int L, int R)
{ // 下放lazytag的索引
    int M = (L + R) >> 1;
    makeTag(u << 1, M - L + 1, lazyTag[u]);
    makeTag(u << 1 | 1, R - M, lazyTag[u]);
    lazyTag[u] = 0;
}
void build(int u, int L, int R)
{ // 递归建树
    if (L == R)
    {
        w[u] = a[L];
        return;
    }
    int M = (L + R) >> 1;
    build(u << 1, L, M);
    build(u << 1 | 1, M + 1, R);
    pushup(u);
}
bool inRange(int L, int R, int l, int r) { return (l <= L) && (R <= r); }  // 判断[L,R]是否被[l,r]包含
bool outofRange(int L, int R, int l, int r) { return (L > r) || (R < l); } // 判断[L,R]是否与[l,r]完全无交集
ll query(int u, int L, int R, int l, int r)
{ // 区间查询
    if (inRange(L, R, l, r))
        return w[u];
    else if (!outofRange(L, R, l, r))
    {
        int M = (L + R) >> 1;
        pushdown(u, L, R);
        return query(u << 1, L, M, l, r) + query(u << 1 | 1, M + 1, R, l, r);
    }
    else
        return 0;
}
void update(int u, int L, int R, int l, int r, ll x)
{ // 区间修改
    if (inRange(L, R, l, r))
        makeTag(u, R - L + 1, x);
    else if (!outofRange(L, R, l, r))
    {
        int M = (L + R) >> 1;
        pushdown(u, L, R);
        update(u << 1, L, M, l, r, x);
        update(u << 1 | 1, M + 1, R, l, r, x);
        pushup(u);
    }
}
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
    {
        cin >> a[i];
    }
    build(1, 1, n);
    for (int i = 1; i <= m; ++i)
    {
        int op, x, y;
        ll k;
        cin >> op;
        if (op == 1)
        {
            cin >> x >> y >> k;
            update(1, 1, n, x, y, k);
        }
        else
        {
            cin >> x >> y;
            cout << query(1, 1, n, x, y) << endl;
        }
    }
    return 0;
}
//线段树区间乘法，区间加法，区间查询
ll n, m, p;
int ls(int u) { return u << 1; }
int rs(int u) { return u << 1 | 1; }
int mid(int l, int r) { return (l + r) >> 1; }
struct Node
{
    ll ad;
    ll mu = 1;
} tag[maxn * 4];
ll a[maxn], w[maxn * 4];
void pushup(int u) { w[u] = (w[ls(u)] + w[rs(u)]) % p; }
void build(int u, int L, int R)
{
    if (L == R)
    {
        w[u] = a[L] % p;
        return;
    }
    int M = mid(L, R);
    build(ls(u), L, M);
    build(rs(u), M + 1, R);
    pushup(u);
}
bool inRange(int L, int R, int l, int r) { return (l <= L) && (R <= r); }  // 判断[L,R]是否被[l,r]包含
bool outofRange(int L, int R, int l, int r) { return (L > r) || (R < l); } // 判断[L,R]是否与[l,r]完全无交集
void pushdown(int u, int L, int R)
{
    int M = mid(L, R);
    if (tag[u].mu != 1)
    {
        tag[ls(u)].ad = tag[ls(u)].ad * tag[u].mu % p;
        tag[rs(u)].ad = tag[rs(u)].ad * tag[u].mu % p;
        tag[ls(u)].mu = tag[ls(u)].mu * tag[u].mu % p;
        tag[rs(u)].mu = tag[rs(u)].mu * tag[u].mu % p;
        w[ls(u)] = w[ls(u)] * tag[u].mu % p;
        w[rs(u)] = w[rs(u)] * tag[u].mu % p;
        tag[u].mu = 1;
    }
    if (tag[u].ad)
    {
        w[ls(u)] = (w[ls(u)] + (M - L + 1) * tag[u].ad) % p;
        tag[ls(u)].ad = (tag[ls(u)].ad + tag[u].ad) % p;
        w[rs(u)] = (w[rs(u)] + (R - M) * tag[u].ad) % p;
        tag[rs(u)].ad = (tag[rs(u)].ad + tag[u].ad) % p;
        tag[u].ad = 0;
    }
}
ll query(int u, int L, int R, int l, int r)
{
    if (inRange(L, R, l, r))
        return w[u];
    else if (!outofRange(L, R, l, r))
    {
        int M = mid(L, R);
        pushdown(u, L, R);
        return (query(ls(u), L, M, l, r) + query(rs(u), M + 1, R, l, r)) % p;
    }
    else
        return 0;
}
void update1(int u, int L, int R, int l, int r, ll k)
{
    if (inRange(L, R, l, r))
    {
        tag[u].mu = tag[u].mu * k % p;
        tag[u].ad = tag[u].ad * k % p;
        w[u] = w[u] * k % p;
        return;
    }
    else if (!outofRange(L, R, l, r))
    {
        int M = mid(L, R);
        pushdown(u, L, R);
        update1(ls(u), L, M, l, r, k);
        update1(rs(u), M + 1, R, l, r, k);
        pushup(u);
    }
}
void update2(int u, int L, int R, int l, int r, ll k)
{
    if (inRange(L, R, l, r))
    {
        tag[u].ad = (tag[u].ad + k) % p;
        w[u] = (w[u] + (R - L + 1) * k) % p;
        return;
    }
    else if (!outofRange(L, R, l, r))
    {
        int M = mid(L, R);
        pushdown(u, L, R);
        update2(ls(u), L, M, l, r, k);
        update2(rs(u), M + 1, R, l, r, k);
        pushup(u);
    }
}
int main()
{
    cin >> n >> m >> p;
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
    build(1, 1, n);
    for (int i = 1; i <= m; ++i)
    {
        int op, x, y;
        ll k;
        cin >> op >> x >> y;
        if (op == 1)
        {
            cin >> k;
            update1(1, 1, n, x, y, k);
        }
        else if (op == 2)
        {
            cin >> k;
            update2(1, 1, n, x, y, k);
        }
        else
        {
            cout << query(1, 1, n, x, y) % p << endl;
        }
    }
    return 0;
}
//树状数组单点修改区间查询
#include <bits/stdc++.h>
using namespace std;
int tree[500010];
int n, m;
int lowbit(int x) { return x & -x; }
void add(int x, int k)
{
    while (x <= n)
    {
        tree[x] += k;
        x += lowbit(x);
    }
}
int sum(int x)
{
    int ans = 0;
    while (x != 0)
    {
        ans += tree[x];
        x -= lowbit(x);
    }
    return ans;
}
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int a;
        cin >> a;
        add(i, a);
    }
    cin >> m;
    for (int i = 1; i <= m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        if (u == 1)
            add(v, w);
        else if (u == 2)
            cout << sum(w) - sum(v - 1) << endl;
    }
    return 0;
}
//树状数组区间修改单点查询
#include <bits/stdc++.h>
using namespace std;
int tree[500010], y[500010];
int n, m;
int lowbit(int x) { return x & -x; }
void add(int x, int k)
{
    while (x <= n)
    {
        tree[x] += k;
        x += lowbit(x);
    }
}
int sum(int x)
{
    int ans = 0;
    while (x != 0)
    {
        ans += tree[x];
        x -= lowbit(x);
    }
    return ans;
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> y[i];
    for (int i = 1; i <= m; i++)
    {
        int u, a, b, c, v;
        cin >> u;
        if (u == 1)
        {
            cin >> a >> b >> c;
            add(a, c);
            add(b + 1, -c);
        }
        else if (u == 2)
        {
            cin >> v;
            cout << y[v] + sum(v) << endl;
        }
    }
    return 0;
}
//树状数组区间修改区间查询
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN (int)(1e6 + 5)

int n,m;
int a[MAXN];
struct BIT{
	int bit1[MAXN],bit2[MAXN];
	int lowbit(int x){return x & (-x);}
	void add(int i, int v){
		int k = v * i;
		while(i <= n){
			bit1[i] += v, bit2[i] += k; // 维护的重点部分
			i += lowbit(i);
		}
	}
	int sum(int *b, int i){
		int res = 0;
		while(i >= 1){
			res += b[i];
			i -= lowbit(i);
		}
		return res;
	}
	int qry(int l, int r){
        return sum(bit1, r) * (r + 1) - sum(bit1, l - 1) * l - (sum(bit2, r) - sum(bit2, l - 1));
    }
}bt; 

signed main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		cin >> a[i], bt.add(i, a[i] - a[i - 1]);
	while(m--){
		int op, l, r, x;
		cin >> op >> l >> r;
		if(op == 1){cin >> x; bt.add(l, x), bt.add(r + 1, -x);}
		if(op == 2){printf("%lld\n", bt.qry(l, r));}
	}
	return 0;
}
```

## 快速幂

```cpp
int qpow(long long a, int b) {
  int ans = 1;
  a = (a % p + p) % p;
  for (; b; b >>= 1) {
    if (b & 1) ans = (a * ans) % p;
    a = (a * a) % p;
  }
  return ans;
}
```

## lucas

```cpp
long long Lucas(long long n, long long m, long long p) {
  if (m == 0) return 1;
  return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```

## 各种背包

```cpp
//01
for (int i = 1; i <= n; i++)
  for (int l = W; l >= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);
//完全
for (int i = 1; i <= n; i++)
    for (int l = w[i]; l <= W; l++)
      if (f[l - w[i]] + v[i] > f[l]) f[l] = f[l - w[i]] + v[i];
//分组
for (int k = 1; k <= ts; k++)          // 循环每一组
  for (int i = m; i >= 0; i--)         // 循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品
      if (i >= w[t[k][j]])             // 背包容量充足
        dp[i] = max(dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
```