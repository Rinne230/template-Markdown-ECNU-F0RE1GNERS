#  杂项

## 线性基

+ 线性基模板(总异或最大值)

```cpp
ll p[64];
void insert(ll x){
    for (int i = 63; ~i; --i){
        if (!(x >> i)) continue;
        if (!p[i]){
            p[i] = x;
            break;
        }
        x ^= p[i];
    }
}
```

+ 区间线性基(区间异或最大值,强制在线)

```cpp
#include<bits/stdc++.h>
#define M 500009
using namespace std;
int read() {
	int f = 1, re = 0; char ch;
	for (ch = getchar(); !isdigit(ch) && ch != '-'; ch = getchar());
	if (ch == '-') {f = -1, ch = getchar();}
	for (; isdigit(ch); ch = getchar()) re = (re << 3) + (re << 1) + ch - '0';
	return re * f;
}
int pos[M][32], p[M][32], t, n, m, lastans;
void insert(int val, int num, int po) {
	for (int i = 30; i >= 0; i--) {
		if (val & (1ll << i)) {
			if (!p[num][i]) {p[num][i] = val, pos[num][i] = po; return;}
			else if (pos[num][i] < po) {
				swap(val, p[num][i]);
				swap(po, pos[num][i]);
			} val ^= p[num][i];
		}
	} return;
}
int query(int l, int r) {
	int ans = 0;
	for (int i = 30; i >= 0; i--)
		if (pos[r][i] >= l && (p[r][i]^ans) > ans) ans ^= p[r][i];
	return ans;
}
signed main() {
	t = read();
	while (t--) {
		n = read(), m = read(); lastans = 0;
		memset(p, 0, sizeof(p));
		memset(pos, 0, sizeof(pos));
		for (int i = 1; i <= n; i++) {
			int x = read();
			for (int j = 0; j <= 30; j++)
				p[i][j] = p[i - 1][j], pos[i][j] = pos[i - 1][j];
			insert(x, i, i);
		}
		for (int i = 1; i <= m; i++) {
			int opt = read();
			if (opt) {
				int x = read()^lastans; n++;
				for (int j = 0; j <= 30; j++)
					p[n][j] = p[n - 1][j], pos[n][j] = pos[n - 1][j];
				insert(x, n, n);
			}
			else {
				int l = (read()^lastans) % n + 1;
				int r = (read()^lastans) % n + 1;
				if (l > r) swap(l, r);
				printf("%d\n", lastans = query(l, r));
			}
		}
	} return 0;
}
```


+ 区间问题(异或和,区间内是否存在异或和为x)

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
constexpr ll maxn = 4e5 + 5;
int pos[65];
ll p[65], t, n, m;
bool ans[maxn];
void insert(ll val, int P)
{
    for (int i = 59; i >= 0; i--)
    {
        if (val & (1ll << i))
        {
            if (!p[i])
            {
                p[i] = val, pos[i] = P;
                return;
            }
            else if (pos[i] < P)
            {
                swap(val, p[i]);
                swap(P, pos[i]);
            }
            val ^= p[i];
        }
    }
    return;
}
bool query(int l, ll val)
{
    for (int i = 59; i >= 0; i--)
    {
        if (val & (1ll << i))
        {
            if (!p[i])
                return false;
            if (pos[i] < l)
                return false;
            val ^= p[i];
        }
    }
    return true;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    vector<ll> a(n + 1);
    vector<tuple<int, int, ll, int>> q(m);
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 0; i < m; i++)
    {
        auto &[l, r, val, id] = q[i];
        cin >> l >> r >> val, id = i;
    }
    sort(q.begin(), q.end(), [&](auto x, auto y)
         {
        auto &[l1,r1,val1,id1] = x;
        auto &[l2,r2,val2,id2] = y;
        return (r1==r2)?(l1<l2):(r1<r2); });
    int R = 0;
    for (int i = 0; i < m; i++)
    {
        auto &[l, r, val, id] = q[i];
        while (R < r)
            insert(a[R + 1], R + 1),R++;
        ans[id] = query(l, val);
    }
    for (int i = 0; i < m; i++)
    {
        cout << (ans[i] ? "Yes\n" : "No\n");
    }

    return 0;
}

```
