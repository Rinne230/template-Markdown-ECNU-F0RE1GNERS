# 区间问题

## 莫队

+ 区间取两个数相同概率

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
using namespace std;
const int N = 50005;
int n, m, maxn;
int c[N];
long long sum;
int cnt[N];
long long ans1[N], ans2[N];

struct query {
  int l, r, id;

  bool operator<(const query &x) const {  // 重载<运算符
    if (l / maxn != x.l / maxn) return l < x.l;
    return (l / maxn) & 1 ? r < x.r : r > x.r;
  }
} a[N];

void add(int i) {
  sum += cnt[i];
  cnt[i]++;
}

void del(int i) {
  cnt[i]--;
  sum -= cnt[i];
}

long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }

int main() {
  scanf("%d%d", &n, &m);
  maxn = sqrt(n);
  for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
  for (int i = 0; i < m; i++) scanf("%d%d", &a[i].l, &a[i].r), a[i].id = i;
  sort(a, a + m);
  for (int i = 0, l = 1, r = 0; i < m; i++) {  // 具体实现
    if (a[i].l == a[i].r) {
      ans1[a[i].id] = 0, ans2[a[i].id] = 1;
      continue;
    }
    while (l > a[i].l) add(c[--l]);
    while (r < a[i].r) add(c[++r]);
    while (l < a[i].l) del(c[l++]);
    while (r > a[i].r) del(c[r--]);
    ans1[a[i].id] = sum;
    ans2[a[i].id] = (long long)(r - l + 1) * (r - l) / 2;
  }
  for (int i = 0; i < m; i++) {
    if (ans1[i] != 0) {
      long long g = gcd(ans1[i], ans2[i]);
      ans1[i] /= g, ans2[i] /= g;
    } else
      ans2[i] = 1;
    printf("%lld/%lld\n", ans1[i], ans2[i]);
  }
  return 0;
}
```

## CDQ

+ 逆序对

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

void solve(){
	int n;
	cin >> n;
	vi a(n + 1), temp(n + 1);
	ll ans = 0;
	rep(i, 1, n) cin >> a[i];
	function<void(int, int)> cdq = [&](int l, int r){
		if (l == r) return;
		int mid = l + r >> 1;
		cdq(l, mid);
		cdq(mid + 1, r);
		int p1 = l, p2 = mid + 1, idx = l;
		while (p1 <= mid && p2 <= r){
			if (a[p1] > a[p2]) temp[idx++] = a[p1++];
			else temp[idx++] = a[p2++], ans += p1 - l;
		}
		while (p1 <= mid) temp[idx++] = a[p1++];
		while (p2 <= r) temp[idx++] = a[p2++], ans += p1 - l;
		for (int i = l; i <= r; ++i) a[i] = temp[i];
	};
	cdq(1, n);
	cout << ans << endl;
}

int main(){
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

+ 求最长不上升子序列和最长上升子序列

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100005;
int n, x, dp[MAXN], a[MAXN], ans;
pair<int, int> temp[MAXN][20]; //val, pos

bool cmp(const pair<int, int> &A, const pair<int, int> &B, const int &type) {
	return type ? A.first != B.first ? A.first > B.first : A.second < B.second : A.first != B.first ? A.first < B.first: A.second > B.second;
}

void mergeSort(int l, int r, int deep, const int &cmptype) {
	if (l == r) {
		temp[l][deep].first = a[l];
		temp[l][deep].second = l;
		return;
	}
	int mid = (l + r) >> 1;
	mergeSort(l, mid, deep + 1, cmptype);
	mergeSort(mid + 1, r, deep + 1, cmptype);
	int p1 = l, p2 = mid + 1;
	while (p1 <= mid && p2 <= r) {
		if (cmp(temp[p1][deep + 1], temp[p2][deep + 1], cmptype)) {
			temp[l++][deep] = temp[p1++][deep + 1];
		} else {
			temp[l++][deep] = temp[p2++][deep + 1];
		}
	}
	while (p1 <= mid) {
		temp[l++][deep] = temp[p1++][deep + 1];
	}
	while (p2 <= r) {
		temp[l++][deep] = temp[p2++][deep + 1];
	}
}

void cdqDivAlgorithm(int l, int r, int deep, const int &cmptype) {
	if (l == r) {
		dp[l] = max(dp[l], 1);
		ans = max(ans, dp[l]);
		return;
	}
	int mid = (l + r) >> 1;
	cdqDivAlgorithm(l, mid, deep + 1, cmptype);
	int p1 = l, p2 = mid + 1, premax = 0;
	while (p1 <= mid && p2 <= r) {
		if (cmp(temp[p1][deep + 1], temp[p2][deep + 1], cmptype)) {
			premax = max(premax, dp[temp[p1++][deep + 1].second]);
		} else {
			dp[temp[p2][deep + 1].second] = max(premax + 1, dp[temp[p2][deep + 1].second]);
			p2++;
		}
	}
	while (p2 <= r) {
		dp[temp[p2][deep + 1].second] = max(premax + 1, dp[temp[p2][deep + 1].second]);
		p2++;
	}
	cdqDivAlgorithm(mid + 1, r, deep + 1, cmptype);
}

int main()
{
	while (scanf("%d", &x) != EOF)a[++n] = x;
	mergeSort(1, n, 0, 1);
	cdqDivAlgorithm(1, n, 0, 1);
	printf("%d\n", ans);
	memset(dp, 0, sizeof(dp));
	ans = 0;
	mergeSort(1, n, 0, 0);
	cdqDivAlgorithm(1, n, 0, 0);
	printf("%d\n", ans);
	return 0;
}
```

+ 求地毯覆盖（最多取多少个不相互覆盖）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1000005;
int n, L[MAXN], R[MAXN], id[MAXN], dp[MAXN], ans;
int temp[MAXN];
void cdqDivAlgorithm(int l, int r) {
    if (l == r) {
        dp[id[l]] = max(1, dp[id[l]]);
        ans = max(ans, dp[id[l]]);
        return;
    }
    int mid = (l + r) >> 1;
    cdqDivAlgorithm(l, mid);
    int p1 = l, pl, p2 = mid + 1, premax = 0;
    while (p1 <= mid && p2 <= r) {
        if (R[id[p1]] <= L[id[p2]]) {
            premax = max(premax, dp[id[p1++]]);
        } else {
            dp[id[p2]] = max(premax + 1, dp[id[p2]]);
            ++p2;
        }
    }
    while (p2 <= r) {
        dp[id[p2]] = max(premax + 1, dp[id[p2]]);
        ++p2;
    }
    cdqDivAlgorithm(mid + 1, r);
    p1 = l, pl = l, p2 = mid + 1;
    while (p1 <= mid && p2 <= r) {
        if (R[id[p1]] < R[id[p2]]) {
            temp[pl++] = id[p1++];
        } else {
            temp[pl++] = id[p2++];
        }
    }
    while (p1 <= mid) {
        temp[pl++] = id[p1++];
    }
    while (p2 <= r) {
        temp[pl++] = id[p2++];
    }
    for (int i = l; i <= r; ++i) {
        id[i] = temp[i];
    }
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d %d", &L[i], &R[i]);
        id[i] = i;
    }
    sort(id + 1, id + 1 + n, [](const int &A, const int &B) {
        return L[A] < L[B];
    });
    cdqDivAlgorithm(1, n);
    printf("%d\n", ans);
    return 0;
}
```

+ 动态凸包

第一行 ：一个整数N ，表示方案和询问的总数。
接下来N行，每行开头一个单词“Query”或“Project”。
若单词为Query，则后接一个整数T，表示Blue Mary询问第T天的最大收益。
若单词为Project，则后接两个实数S，P，表示该种设计方案第一天的收益S，以及以后每天比上一天多出的收益P。对于每一个Query，输出一个整数，表示询问的答案，并精确到整百元
1 <= N <= 100000 1 <= T <=50000 0 < P < 100，| S | <= 10^6

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100005;
const double eps = 1e-6;
int m, n, id[MAXN], qid[MAXN], type[MAXN], x[MAXN], temp[MAXN], top;
double k[MAXN], b[MAXN], ans[MAXN];
char op[55];
inline bool cmp(const int &A, const int &B) {
    return type[A] != type[B] ? type[A] < type[B] : type[A] ? x[A] < x[B] : k[A] < k[B];
}
inline int dcmp(double x) {
    return x > eps ? 1 : x < -eps ? -1 : 0;
}
inline double getCross(const double &k1, const double &b1, const double &k2, const double &b2) {
    return (b2 - b1) / (k1 - k2);
}
inline double getVal(const double &k, const double &b, const int &x)
{
    return k * x + b;
}
pair<double, double>stk[MAXN];
void stkClear() {
    top = 0;
    stk[++top] = make_pair(0, 0);
}
void stkInsert(double k, double b) {
    if (dcmp(stk[top].first - k) == 0 && dcmp(stk[top].second - b) < 0)top--;
    if (dcmp(stk[top].first - k) == 0 && dcmp(stk[top].second - b) >= 0)return;
    while (top >= 2 && dcmp(getCross(stk[top].first, stk[top].second, stk[top - 1].first, stk[top - 1].second) - getCross(stk[top].first, stk[top].second, k, b)) > 0)top--;
    stk[++top] = make_pair(k, b);
}
double stkQuery(int x) {
    while (top >= 2 && dcmp(getVal(stk[top].first, stk[top].second, x) - getVal(stk[top - 1].first, stk[top - 1].second, x)) < 0)--top;
    return getVal(stk[top].first, stk[top].second, x);
}
void cdqDivAlgorithm(int l, int r) {
    if (l == r)return;
    int mid = (l + r) >> 1;
    cdqDivAlgorithm(l, mid);
    cdqDivAlgorithm(mid + 1, r);
    stkClear();
    for (int i = l; i <= mid && !type[id[i]]; ++i) {
        stkInsert(k[id[i]], b[id[i]]);
    }
    for (int i = r; i > mid && type[id[i]]; --i) {
        ans[qid[id[i]]] = max(ans[qid[id[i]]], stkQuery(x[id[i]]));
    }
    int p1 = l, pl = l, p2 = mid + 1;
    while (p1 <= mid && p2 <= r) {
        if (cmp(id[p1], id[p2])) {
            temp[pl++] = id[p1++];
        } else {
            temp[pl++] = id[p2++];
        }
    }
    while (p1 <= mid) {
        temp[pl++] = id[p1++];
    }
    while (p2 <= r) {
        temp[pl++] = id[p2++];
    }
    for (int i = l; i <= r; ++i) {
        id[i] = temp[i];
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        id[i] = i;
        scanf("%s", op);
        if (*op == 'P') {
            type[i] = 0;
            scanf("%lf %lf", &b[i], &k[i]);
            b[i] -= k[i];
        }
        else {
            type[i] = 1;
            qid[i] = ++m;
            scanf("%d", &x[i]);
        }
    }
    cdqDivAlgorithm(1, n);
    for (int i = 1; i <= m; ++i) {
        printf("%d\n", (int)ans[i] / 100);
    }
    return 0;
}

```
