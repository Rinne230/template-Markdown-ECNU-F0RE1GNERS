# 树上问题

## 树剖

+ 2018ICPC青岛网络赛（多测时候用来剖的）

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j, k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

void solve()
{
    int n, m, q, k, cnt = 0;
    cin >> n >> m >> q;
    vi red(n + 1);
    vector<vector<pll>> G(n + 1);
    vl dis(n + 1), dep(n + 1), v(n + 1);
    vi dfn(n + 1), idx(n + 1);
    vi son(n + 1, -1), sz(n + 1), fa(n + 1), top(n + 1);
    function<void(int, int)> dfs1 = [&](int u, int f) {
        son[u] = -1;
        sz[u] = 1;
        if(!red[u])
            red[u] = red[f];
        for(auto [v, w] : G[u]) {
            if(v == f)
                continue;
            dep[v] = dep[u] + 1;
            dis[v] = dis[u] + w;
            fa[v] = u;
            dfs1(v, u);
            sz[u] += sz[v];
            if(son[u] == -1 || sz[v] > sz[son[u]])
                son[u] = v;
        }
    };
    function<void(int, int)> dfs2 = [&](int u, int t) {
        top[u] = t;
        dfn[u] = ++cnt;
        idx[cnt] = u;
        if(son[u] == -1)
            return;
        dfs2(son[u], t);
        for(auto [v, w] : G[u])
            if(v != son[u] && v != fa[u])
                dfs2(v, v);
    };
    auto lca = [&](int u, int v) {
        while(top[u] != top[v]) {
            if(dep[top[u]] > dep[top[v]])
                u = fa[top[u]];
            else
                v = fa[top[v]];
        }
        return dep[u] > dep[v] ? v : u;
    };
    for(int i = 1, x; i <= m; ++i)
        cin >> x, red[x] = x;
    for(int i = 1; i < n; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        G[u].push_back({v, w});
        G[v].push_back({u, w});
    }
    dfs1(1, 0);
    dfs2(1, 1);
    for(int i = 1; i <= n; ++i)
        v[i] = dis[i] - dis[red[i]];
    while(q--) {
        cin >> k;
        vector<int> p(k + 1);
        auto check = [&](ll st) {
            vector<int> q;
            for(int i = 1; i <= k; ++i)
                if(v[p[i]] > st)
                    q.push_back(p[i]);
            if(q.size() == 0)
                return true;
            int mnd = n + 1, mxd = 0;
            for(int i = 0; i < q.size(); ++i) {
                mnd = min(mnd, dfn[q[i]]);
                mxd = max(mxd, dfn[q[i]]);
            }
            int ca = lca(idx[mnd], idx[mxd]);
            for(int i = 0; i < q.size(); ++i)
                if(dis[q[i]] - dis[ca] > st)
                    return false;
            return true;
        };
        ll mx = 0;
        for(int i = 1; i <= k; ++i) {
            cin >> p[i];
            mx = max(mx, v[p[i]]);
        }
        ll l = 0, r = mx;
        while(l < r) {
            ll mid = (l + r) >> 1;
            if(check(mid))
                r = mid;
            else
                l = mid + 1;
        }
        cout << l << endl;
    }
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}

```
+ 树上操作
1.	节点x加上a
2.	节点x的子树中所有点的点权加a
3.	询问某个点x到根节点

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;
const int N = 1e5 + 10, M = N * 2;

int n, m;
// w为节点权值
int h[N], w[N], e[M], ne[M], idx;
// id[x]为节点x的新编号，nw[x]是新编号为x的节点的权值
int id[N], nw[N], cnt;
// dep为深度，sz为子树大小，top[x]是x所在重链的头结点，
// fa[x]为x父亲，son[x]为x的重儿子
int dep[N], sz[N], top[N], fa[N], son[N];
struct Tree {
    int l, r;
    ll sum, add;
} tr[N << 2];

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

// 第一次dfs，求节点深度、父亲、子树大小和重儿子
void dfs1(int u, int from, int depth) {
    dep[u] = depth, fa[u] = from, sz[u] = 1;
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (v == from) continue;
        dfs1(v, u, depth + 1);
        sz[u] += sz[v];
        if (sz[son[u]] < sz[v]) son[u] = v;
    }
}

// 第二次dfs，t为u重链头结点
void dfs2(int u, int t) {
    id[u] = ++cnt, nw[cnt] = w[u], top[u] = t;
    // 到叶子了，直接返回
    if (!son[u]) return;
    // 先遍历重儿子
    dfs2(son[u], t);
    // 遍历轻儿子
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void pushdown(int u) {
    auto &root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
    if (root.add) {
        left.sum += root.add * (left.r - left.l + 1);
        left.add += root.add;
        right.sum += root.add * (right.r - right.l + 1);
        right.add += root.add;
        root.add = 0;
    }
}

void build(int u, int l, int r) {
    tr[u] = {l, r, nw[l], 0};
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

void update(int u, int l, int r, ll k) {
    if (l <= tr[u].l && tr[u].r <= r) {
        tr[u].add += k;
        tr[u].sum += k * (tr[u].r - tr[u].l + 1);
        return;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) update(u << 1, l, r, k);
    if (r > mid) update(u << 1 | 1, l, r, k);
    pushup(u);
}

ll query(int u, int l, int r) {
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    ll res = 0;
    if (l <= mid) res += query(u << 1, l, r);
    if (r > mid) res += query(u << 1 | 1, l, r);
    return res;
}

void update_path(int u, int v, ll k) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        // u的重链头更深，并且u重链头在dfs序里下标更小，直接更新u重链头到u这段区间
        update(1, id[top[u]], id[u], k);
        // u跳到重链头上面
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    update(1, id[v], id[u], k);
}

ll query_path(int u, int v) {
    ll res = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += query(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    res += query(1, id[v], id[u]);
    return res;
}

void update_tree(int u, ll k) {
    update(1, id[u], id[u] + sz[u] - 1, k);
}

ll query_tree(int u) {
    return query(1, id[u], id[u] + sz[u] - 1);
}

void solve() {
    int n, q;
    memset(h, -1, sizeof h);
    cin >> n >> q;
    int cnt = 0;
    for (int i = 1; i <= n; ++i) cin >> w[i];
    for (int i = 1; i <= n - 1; ++i) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    dfs1(1, 1, 0);
    dfs2(1, 1);
    build(1, 1, n);
    while (q--) {
        int t, u;
        ll k;
        cin >> t >> u;
        if (t == 1) {
            cin >> k;
            update_path(u, u, k);
        } else if (t == 2) {
            cin >> k;
            update_tree(u, k);
        } else cout << query_path(1, u) << endl;
    }
}

int main() {
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

+ 树上路径

1. 将以u为根的子树内节点(包括u)的权值加val
2. 将(u, v)路径上的节点权值加val
3. 询问(u, v)路径上节点的权值两两相乘的和

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define int ll
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
const ll inf = 0x3f3f3f3f;
const int N = 1e5 + 10, M = N * 2;

int n, m;
int h[N], a[N], e[M], ne[M], idx;
int id[N], cnt, rnk[N];
int dep[N], sz[N], top[N], fa[N], son[N];
ll inv2;

void add(int u, int v) {
    e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}
ll qmi(ll x, ll k) {
	ll res = 1;
	while (k) {
		if (k & 1) res = res * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return res;
}
struct Segment {
	struct Node {
		int l, r;
		ll sum, psum, add;
	} tr[N * 4];
	void pushup(int u) {
		tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % mod;
		tr[u].psum = (tr[u << 1].psum + tr[u << 1 | 1].psum) % mod;
		return;
	}
	void pushdown(Node& u, Node& l, Node& r) {
		if (u.add) {
			ll x = u.add;
			l.psum = (l.psum + 2 * l.sum * x % mod + (ll)x * x % mod * (l.r - l.l + 1) % mod) % mod;
			r.psum = (r.psum + 2 * r.sum * x % mod + (ll)x * x % mod * (r.r - r.l + 1) % mod) % mod;
			l.sum = (l.sum + (ll)x * (l.r - l.l + 1) % mod) % mod;
			r.sum = (r.sum + (ll)x * (r.r - r.l + 1) % mod) % mod;
			l.add = (l.add + x) % mod;
			r.add = (r.add + x) % mod;
			u.add = 0;
		}
		return;
	}
	void pushdown(int u) {
		pushdown(tr[u], tr[u << 1], tr[u << 1 | 1]);
	}
	void build(int u, int l, int r) {
		tr[u] = {l, r};
		if (l == r) {
			tr[u].sum = a[rnk[l]];
			tr[u].psum = (ll)a[rnk[l]] * a[rnk[l]] % mod;
			return;
		}
		int mid = (l + r) >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		pushup(u);
		return;
	}
	void update(int u, int l, int r, ll x) {
		if (l <= tr[u].l && tr[u].r <= r) {
			tr[u].psum = (tr[u].psum + 2 * tr[u].sum * x % mod + (ll)x * x % mod * (tr[u].r - tr[u].l + 1) % mod) % mod;
			tr[u].sum = (tr[u].sum + (ll)(tr[u].r - tr[u].l + 1) * x % mod) % mod;
			tr[u].add = (tr[u].add + x) % mod;
			return;
		}
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		if (l <= mid) update(u << 1, l, r, x);
		if (mid < r) update(u << 1 | 1, l, r, x);
		pushup(u);
		return;
	}
	ll query_sum(int u, int l, int r) {
		if (l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		ll res = 0;
		if (l <= mid) res = (res + query_sum(u << 1, l, r)) % mod;
		if (mid < r) res = (res + query_sum(u << 1 | 1, l, r)) % mod;
		return res;
	}
	ll query_psum(int u, int l, int r) {
		if (l <= tr[u].l && tr[u].r <= r) return tr[u].psum;
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		ll res = 0;
		if (l <= mid) res = (res + query_psum(u << 1, l, r)) % mod;
		if (mid < r) res = (res + query_psum(u << 1 | 1, l, r)) % mod;
		return res;
	}
} Tr;

//Tree
void dfs1(int u, int from, int depth) {
	dep[u] = depth, fa[u] = from, sz[u] = 1;
	for (int i = h[u]; ~i; i = ne[i]) {
		int v = e[i];
		if (v == from) continue;
		dfs1(v, u, depth + 1);
		sz[u] += sz[v];
		if (sz[son[u]] < sz[v]) son[u] = v;
	}
}
void dfs2(int u, int t) {
	id[u] = ++cnt, top[u] = t;
	rnk[cnt] = u;
	if (!son[u]) return;
	dfs2(son[u], t);
	for (int i = h[u]; ~i; i = ne[i]) {
		int v = e[i];
		if (v == fa[u] || v == son[u]) continue;
		dfs2(v, v);
	}
}
void update_path(int u, int v, ll k) {//更新路径
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		Tr.update(1, id[top[u]], id[u], k);
		u = fa[top[u]];
	}
	if (dep[u] < dep[v]) swap(u, v);
	Tr.update(1, id[v], id[u], k);
}
ll query_path(int u, int v) {
	ll res_sum = 0, res_psum = 0;
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		res_sum = (res_sum + Tr.query_sum(1, id[top[u]], id[u])) % mod;
		res_psum = (res_psum + Tr.query_psum(1, id[top[u]], id[u])) % mod;
		u = fa[top[u]];
	}
	if (dep[u] < dep[v]) swap(u, v);
	res_sum = (res_sum + Tr.query_sum(1, id[v], id[u])) % mod;
	res_psum = (res_psum + Tr.query_psum(1, id[v], id[u])) % mod;
	return (res_sum * res_sum % mod - res_psum + mod) % mod * inv2 % mod;
}
//Tree

void solve() {
	inv2 = qmi(2, mod - 2);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	memset(h, -1, sizeof h);
	for (int i = 1; i <= n - 1; ++i) {
		int u, v;
		cin >> u >> v;
		add(u, v);
		add(v, u);
	}
	dfs1(1, 0, 1);
	dfs2(1, 1);
	Tr.build(1, 1, n);

	while (m--) {
		int op;
		cin >> op;
		ll u, v, k;
		if (op == 1) {
			cin >> u >> k;
			Tr.update(1, id[u], id[u] + sz[u] - 1, k);
		} else if (op == 2) {
			cin >> u >> v >> k;
			update_path(u, v, k);
		} else {
			cin >> u >> v;
			cout << query_path(u, v) << endl;
		}
	}
}

signed main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```

## dsu

+ 树上数颜色

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

int n;

// g[u]: 存储与 u 相邻的结点
vector<int> g[N];

// sz: 子树大小
// big: 重儿子
// col: 结点颜色
// L[u]: 结点 u 的 DFS 序
// R[u]: 结点 u 子树中结点的 DFS 序的最大值
// Node[i]: DFS 序为 i 的结点
// ans: 存答案
// cnt[i]: 颜色为 i 的结点个数
// totColor: 目前出现过的颜色个数
int sz[N], big[N], col[N], L[N], R[N], Node[N], totdfn;
int ans[N], cnt[N], totColor;

void add(int u) {
  if (cnt[col[u]] == 0) ++totColor;
  cnt[col[u]]++;
}

void del(int u) {
  cnt[col[u]]--;
  if (cnt[col[u]] == 0) --totColor;
}

int getAns() { return totColor; }

void dfs0(int u, int p) {
  L[u] = ++totdfn;
  Node[totdfn] = u;
  sz[u] = 1;
  for (int v : g[u])
    if (v != p) {
      dfs0(v, u);
      sz[u] += sz[v];
      if (!big[u] || sz[big[u]] < sz[v]) big[u] = v;
    }
  R[u] = totdfn;
}

void dfs1(int u, int p, bool keep) {
  // 计算轻儿子的答案
  for (int v : g[u])
    if (v != p && v != big[u]) {
      dfs1(v, u, false);
    }
  // 计算重儿子答案并保留计算过程中的数据（用于继承）
  if (big[u]) {
    dfs1(big[u], u, true);
  }
  for (int v : g[u])
    if (v != p && v != big[u]) {
      // 子树结点的 DFS 序构成一段连续区间，可以直接遍历
      for (int i = L[v]; i <= R[v]; i++) {
        add(Node[i]);
      }
    }
  add(u);
  ans[u] = getAns();
  if (keep == false) {
    for (int i = L[u]; i <= R[u]; i++) {
      del(Node[i]);
    }
  }
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%d", &col[i]);
  for (int i = 1; i < n; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs0(1, 0);
  dfs1(1, 0, false);
  for (int i = 1; i <= n; i++) printf("%d%c", ans[i], " \n"[i == n]);
  return 0;
}
```

+ 子树权值不大于k的数量

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll N = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;
int tr[N];
int h[N], to[2 * N], ne[2 * N], cnt;
int sz[N], dep[N], fa[N], son[N];
int top[N], dfn, L[N], R[N], idx[N], skp;
int a[N], sum, ans[N];
int n, m;

vector<pll> q[N];
int lowbit(int x) {return x & -x;}
void add(int p, int k){for (int i = p; i < N; i += lowbit(i)) tr[i] += k;}
int query(int p){int res = 0; for (int i = p; i; i -= lowbit(i)) res += tr[i]; return res;}

void addedge(int u, int v){
	to[++cnt] = v;
	ne[cnt] = h[u];
	h[u] = cnt;
}

void dfs1(int u, int f){
	sz[u] = 1;
	dep[u] = dep[f] + 1;
	fa[u] = f;
	for (int i = h[u]; i; i = ne[i]){
		int v = to[i];
		if (v == f) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (!son[u] || sz[son[u]] < sz[v]) son[u] = v;
	}
}

void dfs2(int u, int t){
	L[u] = ++dfn;
	idx[dfn] = u;
	top[u] = t;
	if (son[u])	dfs2(son[u], t);
	for (int i = h[u]; i; i = ne[i]){
		int v = to[i];
		if (v != fa[u] && v != son[u])
			dfs2(v, v);
	}
	R[u] = dfn;
}

void get(int u, int op){
	for (int i = L[u]; i <= R[u]; ++i){
		if (idx[i] == skp){i = R[idx[i]]; continue;}
		add(a[idx[i]], op);
	}
	if (op == -1) return;
	for (auto x : q[u]) ans[x.second] = query(x.first);
}

void dsu(int u){
	for (int i = h[u]; i; i = ne[i]){
		int v = to[i];
		if (v == fa[u] || v == son[u]) continue;
		dsu(v);
	}
	if (son[u]) {dsu(son[u]), skp = son[u];}
	get(u, 1);
	if (u == top[u]){
		skp = 0;
		get(u, -1);
	}
}
void solve() {
	cin >> n;
	rep(i, 1, n) cin >> a[i];
	int u, v;
	for (int i = 1; i <= n - 1; ++i){
		cin >> u >> v;
		addedge(u, v);
		addedge(v, u);
	}
	cin >> m;
	int x, k;
	rep(i, 1, m){
		cin >> x >> k;
		q[x].push_back({k, i});
	}
	dfs1(1, 0);
	dfs2(1, 1);
	dsu(1);
	for (int i = 1; i <= m; ++i) cout << ans[i] << endl;
}

int main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```
