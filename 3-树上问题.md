# 树上问题

## 树剖

+ 2018ICPC青岛网络赛（多测时候用来剖的）

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j, k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

void solve()
{
    int n, m, q, k, cnt = 0;
    cin >> n >> m >> q;
    vi red(n + 1);
    vector<vector<pll>> G(n + 1);
    vl dis(n + 1), dep(n + 1), v(n + 1);
    vi dfn(n + 1), idx(n + 1);
    vi son(n + 1, -1), sz(n + 1), fa(n + 1), top(n + 1);
    function<void(int, int)> dfs1 = [&](int u, int f) {
        son[u] = -1;
        sz[u] = 1;
        if(!red[u])
            red[u] = red[f];
        for(auto [v, w] : G[u]) {
            if(v == f)
                continue;
            dep[v] = dep[u] + 1;
            dis[v] = dis[u] + w;
            fa[v] = u;
            dfs1(v, u);
            sz[u] += sz[v];
            if(son[u] == -1 || sz[v] > sz[son[u]])
                son[u] = v;
        }
    };
    function<void(int, int)> dfs2 = [&](int u, int t) {
        top[u] = t;
        dfn[u] = ++cnt;
        idx[cnt] = u;
        if(son[u] == -1)
            return;
        dfs2(son[u], t);
        for(auto [v, w] : G[u])
            if(v != son[u] && v != fa[u])
                dfs2(v, v);
    };
    auto lca = [&](int u, int v) {
        while(top[u] != top[v]) {
            if(dep[top[u]] > dep[top[v]])
                u = fa[top[u]];
            else
                v = fa[top[v]];
        }
        return dep[u] > dep[v] ? v : u;
    };
    for(int i = 1, x; i <= m; ++i)
        cin >> x, red[x] = x;
    for(int i = 1; i < n; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        G[u].push_back({v, w});
        G[v].push_back({u, w});
    }
    dfs1(1, 0);
    dfs2(1, 1);
    for(int i = 1; i <= n; ++i)
        v[i] = dis[i] - dis[red[i]];
    while(q--) {
        cin >> k;
        vector<int> p(k + 1);
        auto check = [&](ll st) {
            vector<int> q;
            for(int i = 1; i <= k; ++i)
                if(v[p[i]] > st)
                    q.push_back(p[i]);
            if(q.size() == 0)
                return true;
            int mnd = n + 1, mxd = 0;
            for(int i = 0; i < q.size(); ++i) {
                mnd = min(mnd, dfn[q[i]]);
                mxd = max(mxd, dfn[q[i]]);
            }
            int ca = lca(idx[mnd], idx[mxd]);
            for(int i = 0; i < q.size(); ++i)
                if(dis[q[i]] - dis[ca] > st)
                    return false;
            return true;
        };
        ll mx = 0;
        for(int i = 1; i <= k; ++i) {
            cin >> p[i];
            mx = max(mx, v[p[i]]);
        }
        ll l = 0, r = mx;
        while(l < r) {
            ll mid = (l + r) >> 1;
            if(check(mid))
                r = mid;
            else
                l = mid + 1;
        }
        cout << l << endl;
    }
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}

```
+ 树上操作
1.	节点x加上a
2.	节点x的子树中所有点的点权加a
3.	询问某个点x到根节点

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;
const int N = 1e5 + 10, M = N * 2;

int n, m;
// w为节点权值
int h[N], w[N], e[M], ne[M], idx;
// id[x]为节点x的新编号，nw[x]是新编号为x的节点的权值
int id[N], nw[N], cnt;
// dep为深度，sz为子树大小，top[x]是x所在重链的头结点，
// fa[x]为x父亲，son[x]为x的重儿子
int dep[N], sz[N], top[N], fa[N], son[N];
struct Tree {
    int l, r;
    ll sum, add;
} tr[N << 2];

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

// 第一次dfs，求节点深度、父亲、子树大小和重儿子
void dfs1(int u, int from, int depth) {
    dep[u] = depth, fa[u] = from, sz[u] = 1;
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (v == from) continue;
        dfs1(v, u, depth + 1);
        sz[u] += sz[v];
        if (sz[son[u]] < sz[v]) son[u] = v;
    }
}

// 第二次dfs，t为u重链头结点
void dfs2(int u, int t) {
    id[u] = ++cnt, nw[cnt] = w[u], top[u] = t;
    // 到叶子了，直接返回
    if (!son[u]) return;
    // 先遍历重儿子
    dfs2(son[u], t);
    // 遍历轻儿子
    for (int i = h[u]; ~i; i = ne[i]) {
        int v = e[i];
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void pushdown(int u) {
    auto &root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
    if (root.add) {
        left.sum += root.add * (left.r - left.l + 1);
        left.add += root.add;
        right.sum += root.add * (right.r - right.l + 1);
        right.add += root.add;
        root.add = 0;
    }
}

void build(int u, int l, int r) {
    tr[u] = {l, r, nw[l], 0};
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    pushup(u);
}

void update(int u, int l, int r, ll k) {
    if (l <= tr[u].l && tr[u].r <= r) {
        tr[u].add += k;
        tr[u].sum += k * (tr[u].r - tr[u].l + 1);
        return;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) update(u << 1, l, r, k);
    if (r > mid) update(u << 1 | 1, l, r, k);
    pushup(u);
}

ll query(int u, int l, int r) {
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    ll res = 0;
    if (l <= mid) res += query(u << 1, l, r);
    if (r > mid) res += query(u << 1 | 1, l, r);
    return res;
}

void update_path(int u, int v, ll k) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        // u的重链头更深，并且u重链头在dfs序里下标更小，直接更新u重链头到u这段区间
        update(1, id[top[u]], id[u], k);
        // u跳到重链头上面
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    update(1, id[v], id[u], k);
}

ll query_path(int u, int v) {
    ll res = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += query(1, id[top[u]], id[u]);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    res += query(1, id[v], id[u]);
    return res;
}

void update_tree(int u, ll k) {
    update(1, id[u], id[u] + sz[u] - 1, k);
}

ll query_tree(int u) {
    return query(1, id[u], id[u] + sz[u] - 1);
}

void solve() {
    int n, q;
    memset(h, -1, sizeof h);
    cin >> n >> q;
    int cnt = 0;
    for (int i = 1; i <= n; ++i) cin >> w[i];
    for (int i = 1; i <= n - 1; ++i) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    dfs1(1, 1, 0);
    dfs2(1, 1);
    build(1, 1, n);
    while (q--) {
        int t, u;
        ll k;
        cin >> t >> u;
        if (t == 1) {
            cin >> k;
            update_path(u, u, k);
        } else if (t == 2) {
            cin >> k;
            update_tree(u, k);
        } else cout << query_path(1, u) << endl;
    }
}

int main() {
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

+ 树上路径

1. 将以u为根的子树内节点(包括u)的权值加val
2. 将(u, v)路径上的节点权值加val
3. 询问(u, v)路径上节点的权值两两相乘的和

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define int ll
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll mod = 1e9 + 7;
const ll inf = 0x3f3f3f3f;
const int N = 1e5 + 10, M = N * 2;

int n, m;
int h[N], a[N], e[M], ne[M], idx;
int id[N], cnt, rnk[N];
int dep[N], sz[N], top[N], fa[N], son[N];
ll inv2;

void add(int u, int v) {
    e[idx] = v, ne[idx] = h[u], h[u] = idx++;
}
ll qmi(ll x, ll k) {
	ll res = 1;
	while (k) {
		if (k & 1) res = res * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return res;
}
struct Segment {
	struct Node {
		int l, r;
		ll sum, psum, add;
	} tr[N * 4];
	void pushup(int u) {
		tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % mod;
		tr[u].psum = (tr[u << 1].psum + tr[u << 1 | 1].psum) % mod;
		return;
	}
	void pushdown(Node& u, Node& l, Node& r) {
		if (u.add) {
			ll x = u.add;
			l.psum = (l.psum + 2 * l.sum * x % mod + (ll)x * x % mod * (l.r - l.l + 1) % mod) % mod;
			r.psum = (r.psum + 2 * r.sum * x % mod + (ll)x * x % mod * (r.r - r.l + 1) % mod) % mod;
			l.sum = (l.sum + (ll)x * (l.r - l.l + 1) % mod) % mod;
			r.sum = (r.sum + (ll)x * (r.r - r.l + 1) % mod) % mod;
			l.add = (l.add + x) % mod;
			r.add = (r.add + x) % mod;
			u.add = 0;
		}
		return;
	}
	void pushdown(int u) {
		pushdown(tr[u], tr[u << 1], tr[u << 1 | 1]);
	}
	void build(int u, int l, int r) {
		tr[u] = {l, r};
		if (l == r) {
			tr[u].sum = a[rnk[l]];
			tr[u].psum = (ll)a[rnk[l]] * a[rnk[l]] % mod;
			return;
		}
		int mid = (l + r) >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		pushup(u);
		return;
	}
	void update(int u, int l, int r, ll x) {
		if (l <= tr[u].l && tr[u].r <= r) {
			tr[u].psum = (tr[u].psum + 2 * tr[u].sum * x % mod + (ll)x * x % mod * (tr[u].r - tr[u].l + 1) % mod) % mod;
			tr[u].sum = (tr[u].sum + (ll)(tr[u].r - tr[u].l + 1) * x % mod) % mod;
			tr[u].add = (tr[u].add + x) % mod;
			return;
		}
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		if (l <= mid) update(u << 1, l, r, x);
		if (mid < r) update(u << 1 | 1, l, r, x);
		pushup(u);
		return;
	}
	ll query_sum(int u, int l, int r) {
		if (l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		ll res = 0;
		if (l <= mid) res = (res + query_sum(u << 1, l, r)) % mod;
		if (mid < r) res = (res + query_sum(u << 1 | 1, l, r)) % mod;
		return res;
	}
	ll query_psum(int u, int l, int r) {
		if (l <= tr[u].l && tr[u].r <= r) return tr[u].psum;
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		ll res = 0;
		if (l <= mid) res = (res + query_psum(u << 1, l, r)) % mod;
		if (mid < r) res = (res + query_psum(u << 1 | 1, l, r)) % mod;
		return res;
	}
} Tr;

//Tree
void dfs1(int u, int from, int depth) {
	dep[u] = depth, fa[u] = from, sz[u] = 1;
	for (int i = h[u]; ~i; i = ne[i]) {
		int v = e[i];
		if (v == from) continue;
		dfs1(v, u, depth + 1);
		sz[u] += sz[v];
		if (sz[son[u]] < sz[v]) son[u] = v;
	}
}
void dfs2(int u, int t) {
	id[u] = ++cnt, top[u] = t;
	rnk[cnt] = u;
	if (!son[u]) return;
	dfs2(son[u], t);
	for (int i = h[u]; ~i; i = ne[i]) {
		int v = e[i];
		if (v == fa[u] || v == son[u]) continue;
		dfs2(v, v);
	}
}
void update_path(int u, int v, ll k) {//更新路径
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		Tr.update(1, id[top[u]], id[u], k);
		u = fa[top[u]];
	}
	if (dep[u] < dep[v]) swap(u, v);
	Tr.update(1, id[v], id[u], k);
}
ll query_path(int u, int v) {
	ll res_sum = 0, res_psum = 0;
	while (top[u] != top[v]) {
		if (dep[top[u]] < dep[top[v]]) swap(u, v);
		res_sum = (res_sum + Tr.query_sum(1, id[top[u]], id[u])) % mod;
		res_psum = (res_psum + Tr.query_psum(1, id[top[u]], id[u])) % mod;
		u = fa[top[u]];
	}
	if (dep[u] < dep[v]) swap(u, v);
	res_sum = (res_sum + Tr.query_sum(1, id[v], id[u])) % mod;
	res_psum = (res_psum + Tr.query_psum(1, id[v], id[u])) % mod;
	return (res_sum * res_sum % mod - res_psum + mod) % mod * inv2 % mod;
}
//Tree

void solve() {
	inv2 = qmi(2, mod - 2);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	memset(h, -1, sizeof h);
	for (int i = 1; i <= n - 1; ++i) {
		int u, v;
		cin >> u >> v;
		add(u, v);
		add(v, u);
	}
	dfs1(1, 0, 1);
	dfs2(1, 1);
	Tr.build(1, 1, n);

	while (m--) {
		int op;
		cin >> op;
		ll u, v, k;
		if (op == 1) {
			cin >> u >> k;
			Tr.update(1, id[u], id[u] + sz[u] - 1, k);
		} else if (op == 2) {
			cin >> u >> v >> k;
			update_path(u, v, k);
		} else {
			cin >> u >> v;
			cout << query_path(u, v) << endl;
		}
	}
}

signed main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```

## dsu

+ 树上数颜色

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

int n;

// g[u]: 存储与 u 相邻的结点
vector<int> g[N];

// sz: 子树大小
// big: 重儿子
// col: 结点颜色
// L[u]: 结点 u 的 DFS 序
// R[u]: 结点 u 子树中结点的 DFS 序的最大值
// Node[i]: DFS 序为 i 的结点
// ans: 存答案
// cnt[i]: 颜色为 i 的结点个数
// totColor: 目前出现过的颜色个数
int sz[N], big[N], col[N], L[N], R[N], Node[N], totdfn;
int ans[N], cnt[N], totColor;

void add(int u) {
  if (cnt[col[u]] == 0) ++totColor;
  cnt[col[u]]++;
}

void del(int u) {
  cnt[col[u]]--;
  if (cnt[col[u]] == 0) --totColor;
}

int getAns() { return totColor; }

void dfs0(int u, int p) {
  L[u] = ++totdfn;
  Node[totdfn] = u;
  sz[u] = 1;
  for (int v : g[u])
    if (v != p) {
      dfs0(v, u);
      sz[u] += sz[v];
      if (!big[u] || sz[big[u]] < sz[v]) big[u] = v;
    }
  R[u] = totdfn;
}

void dfs1(int u, int p, bool keep) {
  // 计算轻儿子的答案
  for (int v : g[u])
    if (v != p && v != big[u]) {
      dfs1(v, u, false);
    }
  // 计算重儿子答案并保留计算过程中的数据（用于继承）
  if (big[u]) {
    dfs1(big[u], u, true);
  }
  for (int v : g[u])
    if (v != p && v != big[u]) {
      // 子树结点的 DFS 序构成一段连续区间，可以直接遍历
      for (int i = L[v]; i <= R[v]; i++) {
        add(Node[i]);
      }
    }
  add(u);
  ans[u] = getAns();
  if (keep == false) {
    for (int i = L[u]; i <= R[u]; i++) {
      del(Node[i]);
    }
  }
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) scanf("%d", &col[i]);
  for (int i = 1; i < n; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs0(1, 0);
  dfs1(1, 0, false);
  for (int i = 1; i <= n; i++) printf("%d%c", ans[i], " \n"[i == n]);
  return 0;
}
```

+ 子树权值不大于k的数量

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll N = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;
int tr[N];
int h[N], to[2 * N], ne[2 * N], cnt;
int sz[N], dep[N], fa[N], son[N];
int top[N], dfn, L[N], R[N], idx[N], skp;
int a[N], sum, ans[N];
int n, m;

vector<pll> q[N];
int lowbit(int x) {return x & -x;}
void add(int p, int k){for (int i = p; i < N; i += lowbit(i)) tr[i] += k;}
int query(int p){int res = 0; for (int i = p; i; i -= lowbit(i)) res += tr[i]; return res;}

void addedge(int u, int v){
	to[++cnt] = v;
	ne[cnt] = h[u];
	h[u] = cnt;
}

void dfs1(int u, int f){
	sz[u] = 1;
	dep[u] = dep[f] + 1;
	fa[u] = f;
	for (int i = h[u]; i; i = ne[i]){
		int v = to[i];
		if (v == f) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (!son[u] || sz[son[u]] < sz[v]) son[u] = v;
	}
}

void dfs2(int u, int t){
	L[u] = ++dfn;
	idx[dfn] = u;
	top[u] = t;
	if (son[u])	dfs2(son[u], t);
	for (int i = h[u]; i; i = ne[i]){
		int v = to[i];
		if (v != fa[u] && v != son[u])
			dfs2(v, v);
	}
	R[u] = dfn;
}

void get(int u, int op){
	for (int i = L[u]; i <= R[u]; ++i){
		if (idx[i] == skp){i = R[idx[i]]; continue;}
		add(a[idx[i]], op);
	}
	if (op == -1) return;
	for (auto x : q[u]) ans[x.second] = query(x.first);
}

void dsu(int u){
	for (int i = h[u]; i; i = ne[i]){
		int v = to[i];
		if (v == fa[u] || v == son[u]) continue;
		dsu(v);
	}
	if (son[u]) {dsu(son[u]), skp = son[u];}
	get(u, 1);
	if (u == top[u]){
		skp = 0;
		get(u, -1);
	}
}
void solve() {
	cin >> n;
	rep(i, 1, n) cin >> a[i];
	int u, v;
	for (int i = 1; i <= n - 1; ++i){
		cin >> u >> v;
		addedge(u, v);
		addedge(v, u);
	}
	cin >> m;
	int x, k;
	rep(i, 1, m){
		cin >> x >> k;
		q[x].push_back({k, i});
	}
	dfs1(1, 0);
	dfs2(1, 1);
	dsu(1);
	for (int i = 1; i <= m; ++i) cout << ans[i] << endl;
}

int main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```

+ 子树查询类问题

现在将会问你m个问题。
对于每个问题，它将会给你三个参数x,l,r表示询问以x为根的子树中，节点深度在该子树中不小于l且不大于r的所有节点。你需要告诉智乃酱三个信息，所有符合条件节点的最小值，最大值，以及它们的和。

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e5 + 10;
const ll mod = 998244353;
const ll inf32 = 1e9;
const ll inf64 = 2e18;

int tot, h[maxn], len[maxn], L[maxn], R[maxn], fa[maxn], son[maxn], dfn, n, m, x, l, r, u, v;
ll val[maxn];

struct node {
	ll Sum, Max, Min;
} ans[maxn];

struct qnode {
	int id;
	int l, r;
	qnode(int _id = 0, int _l = 0, int _r = 0) {id = _id, l = _l, r = _r;}
};

struct edges {
	int to, next;
} e[2 * maxn];
vector<qnode> lis[maxn];

struct tnode
{
	ll Sum, Max, Min;
	int l, r;
};
tnode operator + (const tnode &a, const tnode &b)
{
	tnode c;
	c.l = a.l;
	c.r = b.r;
	c.Sum = a.Sum + b.Sum;
	c.Max = max(a.Max, b.Max);
	c.Min = min(a.Min, b.Min);
	return c;
}

struct Segment_Tree
{
	tnode t[4 * maxn];
	int mp[maxn];
	void update (int root)
	{
		int ch = root << 1;
		t[root] = t[ch] + t[ch + 1];
	}
	void buildt(int root, int l, int r)
	{
		t[root].l = l;
		t[root].r = r;
		if (l != r)
		{
			int mid = (l + r) >> 1;
			int ch = root << 1;
			buildt(ch, l, mid);
			buildt(ch + 1, mid + 1, r);
			update(root);
		}
		else
		{
			mp[l] = root;
			t[root].Max = -inf64;
			t[root].Min = inf64;
			t[root].Sum = 0;
		}
	}
	void change(int pos, long long delta, long long nmax, long long nmin)
	{
		int root = mp[pos];
		t[root].Sum += delta;
		t[root].Max = max(t[root].Max, nmax);
		t[root].Min = min(t[root].Min, nmin);
		while (root >>= 1)update(root);
	}
	tnode getdata(int pos)
	{
		return t[mp[pos]];
	}
	tnode getseg(int root, int l, int r)
	{
		if (t[root].l == l && t[root].r == r)
		{
			return t[root];
		}
		int mid = (t[root].l + t[root].r) >> 1;
		int ch = root << 1;
		if (r <= mid)return getseg(ch, l, r);
		else if (l > mid)return getseg(ch + 1, l, r);
		else return getseg(ch, l, mid) + getseg(ch + 1, mid + 1, r);
	}
};
Segment_Tree ST;

void add_edge(int u, int to)
{
	e[++tot].to = to;
	e[tot].next = h[u];
	h[u] = tot;
	return;
}


void dfs1(int x, int father)
{
	fa[x] = father;
	for (int i = h[x]; i; i = e[i].next)
	{
		if (e[i].to != father)
		{
			dfs1(e[i].to, x);
			if (!son[x] || len[son[x]] < len[e[i].to])son[x] = e[i].to;
		}
	}
	len[x] = len[son[x]] + 1;
	return;
}

void dfs2(int x)
{
	L[x] = ++dfn;
	R[x] = L[x] + len[x] - 1;
	if (son[x])dfs2(son[x]);
	for (int i = h[x]; i; i = e[i].next)
	{
		if (e[i].to != fa[x] && e[i].to != son[x])
		{
			dfs2(e[i].to);
		}
	}
	return;
}

void dfs(int x)
{
	if (son[x])
	{
		dfs(son[x]);
	}
	for (int i = h[x]; i; i = e[i].next)
	{
		if (e[i].to != fa[x] && e[i].to != son[x])
		{
			dfs(e[i].to);
			for (int j = L[e[i].to], k = 1; j <= R[e[i].to]; ++j, ++k)
			{
				tnode temp = ST.getdata(j);
				ST.change(L[x] + k, temp.Sum, temp.Max, temp.Min);
			}
		}
	}
	ST.change(L[x], val[x], val[x], val[x]);
	for (auto &i : lis[x])
	{
		tnode temp = ST.getseg(1, L[x] + i.l, L[x] + i.r);
		ans[i.id].Sum = temp.Sum;
		ans[i.id].Max = temp.Max;
		ans[i.id].Min = temp.Min;
	}
	return;
}

void solve() {
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> val[i];
	for (int i = 1; i <= n - 1; ++i) {
		cin >> u >> v;
		add_edge(u, v);
		add_edge(v, u);
	}
	dfs1(1, 0);
	dfs2(1);
	ST.buildt(1, 1, n);
	cin >> m;
	for (int i = 1; i <= m; ++i) {
		cin >> x >> l >> r;
		lis[x].push_back(qnode(i, l, r));
	}
	dfs(1);
	for (int i = 1; i <= m; ++i)
	{
		cout << ans[i].Min << " " <<  ans[i].Max << " " << ans[i].Sum << endl;
	}
}

int main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}

```

+ 小Q与树

u∑v∑min(a[u], a[v]) * dis(u, v)

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define int ll
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int n, h[maxn], to[maxn << 1], nxt[maxn << 1], cnt = 0;
int sz[maxn], son[maxn], dep[maxn], L[maxn], R[maxn], f[maxn], idx[maxn], top[maxn], dfn = 0;
ll sum[maxn], ans = 0;
struct node {
	int x, id;
} a[maxn];

void add(int u, int v) {
	to[++cnt] = v;
	nxt[cnt] = h[u];
	h[u] = cnt;
}

void dfs1(int u, int fa) {
	f[u] = fa;
	dep[u] = dep[fa] + 1;
	sz[u] = 1;
	for (int i = h[u]; i; i = nxt[i]) {
		int v = to[i];
		if (v == fa) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (sz[v] > sz[son[u]])
			son[u] = v;
	}
}

void dfs2(int u, int t) {
	top[u] = t;
	L[u] = ++dfn;
	idx[dfn] = u;
	if (son[u]) dfs2(son[u], t);
	for (int i = h[u]; i; i = nxt[i]) {
		int v = to[i];
		if (v == f[u] || v == son[u]) continue;
		dfs2(v, v);
	}
	R[u] = dfn;
}

struct Segment {
	struct Node {
		int l, r;
		int sum, add;
	} tr[maxn * 4];
	void pushup(int u) {
		tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
	}
	void pushdown(int u) {
		if (tr[u].add) {
			int x = tr[u].add;
			tr[u << 1].sum += (tr[u << 1].r - tr[u << 1].l + 1) * x;
			tr[u << 1 | 1].sum += (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1) * x;
			tr[u << 1].add += x;
			tr[u << 1 | 1].add += x;
			tr[u].add = 0;
		}
		return;
	}
	void build(int u, int l, int r) {
		tr[u] = {l, r};
		if (l == r) return;
		int mid = (l + r) >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		return;
	}
	void modify(int u, int l, int r, int x) {
		if (l <= tr[u].l && tr[u].r <= r) {
			tr[u].add += x;
			tr[u].sum += (tr[u].r - tr[u].l + 1) * x;
			return;
		}
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		if (l <= mid) modify(u << 1, l, r, x);
		if (mid < r) modify(u << 1 | 1, l, r, x);
		pushup(u);
		return;
	}
	int query(int u, int l, int r) {
		if (l <= tr[u].l && tr[u].r <= r) return tr[u].sum;
		pushdown(u);
		int mid = (tr[u].l + tr[u].r) >> 1;
		int res = 0;
		if (l <= mid) res += query(u << 1, l, r);
		if (mid < r) res += query(u << 1 | 1, l, r);
		return res;
	}
} Tr;

void tree_add(int x, int y) {
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		Tr.modify(1, L[top[x]], L[x], 1);
		x = f[top[x]];
	}
	if (dep[x] < dep[y]) swap(x, y);
	Tr.modify(1, L[y], L[x], 1);
	return;
}

int tree_sum(int x, int y) {
	int res = 0;
	while (top[x] != top[y]) {
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		res += Tr.query(1, L[top[x]], L[x]);
		x = f[top[x]];
	}
	if (dep[x] < dep[y]) swap(x, y);
	res += Tr.query(1, L[y], L[x]);
	return res;
}

void solve() {
	cin >> n;
	rep(i, 1, n) {
		cin >> a[i].x;
		a[i].id = i;
	}
	sort(a + 1, a + n + 1, [&](node p, node q) {return p.x > q.x;});
	rep(i, 1, n - 1) {
		int u, v;
		cin >> u >> v;
		add(u, v);
		add(v, u);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	Tr.build(1, 1, n);
	rep(i, 1, n) sum[i] = sum[i - 1] + dep[a[i].id];
	rep(i, 1, n){
		int x = a[i].id;
		ans = (ans + (ll)dep[x] * (i - 1) * a[i].x % mod + sum[i - 1] * a[i].x % mod - 2ll * a[i].x * tree_sum(1, x) % mod + mod) % mod;
		tree_add(1, x);
	}
	cout << ans * 2ll % mod << endl;
}
signed main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```
