# 字符串

## 字符串哈希

+ 取双模

```cpp
#include<bits/stdc++.h>
#include<unordered_map>
#define debug cout << "debug---  "
#define debug_ cout << "\n---debug---\n"
#define oper(a) operator<(const a& ee)const
#define forr(a,b,c) for(int a=b;a<=c;a++)
#define mem(a,b) memset(a,b,sizeof a)
#define cinios (ios::sync_with_stdio(false),cin.tie(0),cout.tie(0))
#define all(a) a.begin(),a.end()
#define sz(a) (int)a.size()
#define endl "\n"
#define ul (u << 1)
#define ur (u << 1 | 1)
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
typedef pair<ll, int> PII;

const int N = 1e5 + 10, M = 2e6 + 10, mod = 1e9 + 7;
int INF = 0x3f3f3f3f; ll LNF = 0x3f3f3f3f3f3f3f3f;
int n, m, B = 10, ki;

const int mod1 = 1e9 + 9;

ll p1[N], P1 = 131, p2[N], P2 = 13331;
ll h[N], h2[N];
//乘法开ll，mod取int

int get1(int l, int r) {
    return (h[r] - (h[l - 1] * p1[r - l + 1]) % mod + mod) % mod;
}
int get2(int l, int r) {
    return (h2[r] - (h2[l - 1] * p2[r - l + 1]) % mod1 + mod1) % mod1;
}

char str[N];

void solve() {
    cin >> n >> m;
    cin >> str + 1;

    p1[0] = p2[0] = 1;

    for (int i = 1; i <= n; i++) {
        p1[i] = (p1[i - 1] * P1) % mod;
        p2[i] = (p2[i - 1] * P2) % mod1;

        h[i] = ((h[i - 1] * P1) % mod + str[i] - '0' + 1) % mod;
        h2[i] = ((h2[i - 1] * P2) % mod1 + str[i] - '0' + 1) % mod1;
    }

    while (m--)
    {
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if (get1(l1, r1) == get1(l2, r2) && get2(l1, r1) == get2(l2, r2)) cout << "Yes\n";
        else cout << "No\n";
    }
}

signed main() {
    cinios;
    int T = 1;
    for (int t = 1; t <= T; t++) {
        solve();
    }
    return 0;
}
```
## KMP

+ KMP模板

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

vector<int> prefix_function(string s)
{
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 2; i < n; i++)
    {
        pi[i] = pi[i - 1];
        while (pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
    }
    return pi;
}

int main(void)
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    string s1, s2;
    cin >> s1 >> s2;
    s1 = " " + s1;
    s2 = " " + s2;
    auto nxt = prefix_function(s2);
    for (int i = 1, j = 0; i < s1.size(); i++)
    {
        while (j && s1[i] != s2[j + 1])
            j = nxt[j];
        if (s1[i] == s2[j + 1])
            j++;
        if (j == s2.size() - 1)
        {
            cout << i - j + 1 << "\n";
            j = nxt[j];
        }
    }
    for (int i = 1; i < s2.size(); i++)
        cout << nxt[i] << " ";

    return 0;
}
```

+ carpet(二维KMP)有一个n*m的地毯，aij表示地毯每格的元素，bij表示地毯每格的价格，要求选取一块价格最大值最小的地毯，并且这块地毯无限铺开之后，原地毯是其子矩阵

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define x first
#define y second
#define int ll
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

vector<int> prefix_function(string s)
{
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 2; i < n; i++)
    {
        pi[i] = pi[i - 1];
        while (pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
    }
    return pi;
}

int get_length(vector<string> s)
{
    int len = s[1].size() - 1;
    int ret = len;
    vector<int> cnt(len + 1);
    for (int i = 1; i < s.size(); ++i)
    {
        string tmp = s[i];
        auto nxt = prefix_function(tmp);
        int j = len;
        while (j)
        {
            cnt[len - nxt[j]]++;
            j = nxt[j];
        }
    }
    for (int i = 1; i <= len; ++i)
        if (cnt[i] == s.size() - 1)
        {
            ret = i;
            break;
        }
    return ret;
}

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<string> s1(n + 1);
    for (int i = 1; i <= n; ++i)
        cin >> s1[i], s1[i] = " " + s1[i];
    vector<string> s2(m + 1);
    for (int i = 1; i <= m; ++i)
    {
        string tmp = " ";
        for (int j = 1; j <= n; ++j)
            tmp += s1[j][i];
        s2[i] = tmp;
    }
    vector<vector<int>> a(n + 1, vector<int>(m + 1, 0));
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            cin >> a[i][j];
    int p = get_length(s1), q = get_length(s2);
    ll ans = 1e9;
    deque<int> dq;
    auto b = a;
    for (int i = 1; i <= n; ++i){
        while (dq.size()) dq.pop_back();
        for (int j = 1; j <= m; ++j){
            while (dq.size() && j - dq.front() + 1 > p) dq.pop_front();
            while (dq.size() && a[i][dq.back()] <= a[i][j]) dq.pop_back();
            dq.push_back(j);
            b[i][j] = a[i][dq.front()];
        }
    }
    for (int j = 1; j <= m; ++j){
        while (dq.size()) dq.pop_back();
        for (int i = 1; i <= n; ++i){
            while (dq.size() && i - dq.front() + 1 > q) dq.pop_front();
            while (dq.size() && b[dq.back()][j] <= b[i][j]) dq.pop_back();
            dq.push_back(i);
            if (i >= q && j >= p)
                ans = min(ans, 1ll * b[dq.front()][j]);
        }
    }
    ans = ans * (p + 1) * (q + 1);
    cout << ans << endl;
}

signed main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}

```

## Trie

+ trie & topo

可自定字符间大小关系，求多少个串可以成为字典序最小的串

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define x first
#define y second
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 3e4 + 10, maxm = (3e4 + 10) * 26;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int tr[maxm][26], idx = 0;
bool vis[maxm];
vector<int> edge[26];
int in[26];

void insert(string s)
{
    int x = 0;
    for (auto op : s)
    {
        auto c = op - 'a';
        if (!tr[x][c])
            tr[x][c] = ++idx;
        x = tr[x][c];
    }
    vis[x] = 1;
}

bool query(string s)
{
    auto topo = [&](){
        queue<int> q;
        int cnt = 0;
        for (int i = 0; i < 26; ++i) if (!in[i]) q.push(i);
        while(!q.empty()){
            auto op = q.front();
            q.pop(), cnt++;
            for (auto v : edge[op]){
                if (!--in[v]) q.push(v);
            }
        }
        return cnt == 26;
    };

    int x = 0;
    for (int i = 0; i < s.size(); ++i){
        auto c = s[i] - 'a';
        for (int j = 0; j < 26; ++j){
            if (j == c || !tr[x][j]) continue;
            edge[c].push_back(j);
            in[j]++;
        }
        x = tr[x][c];
        if (vis[x] && i != s.size() - 1) return false;
    }
    return topo();
}

void solve()
{
    int n;
    cin >> n;
    vector<string> v(n + 1);
    for (int i = 1; i <= n; ++i)
    {
        cin >> v[i];
        insert(v[i]);
    }
    vector<string> res;
    for (int op = 1; op <= n; ++op)
    {
        for (int i = 0; i < 26; ++i)
            in[i] = 0, edge[i].clear();
        if (query(v[op]))
            res.push_back(v[op]);
    }
    cout << res.size() << endl;
    for (auto s : res)
        cout << s << endl;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

## 01Trie

+ 两数最大异或和

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll maxm = maxn * 32;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int tr[maxm][2], idx, n;

void insert(int x){
    int p = 0;
    for (int i = 31; i >= 0; --i){
        int c = x >> i & 1;
        if (!tr[p][c]) tr[p][c] = ++idx;
        p = tr[p][c];
    }
}

int query(int x){
    int res = 0, p = 0;
    for (int i = 31; i >= 0; --i){
        int c = x >> i & 1;
        if (tr[p][c ^ 1]){
            p = tr[p][c ^ 1];
            res += 1 << i;
        }else
            p = tr[p][c];
    }
    return res;
}

void solve(){
    cin >> n;
    int ans = 0;
    for (int i = 0; i < n; ++i){
        int x; cin >> x;
        ans = max(ans, query(x));
        insert(x);
    }
    cout << ans << endl;
}

int main(){
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

+ 区间异或最大值

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll maxm = maxn * 21;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int a[maxn], s[maxn];
int tr[maxm][2], tot;

void insert(int x)
{
    int p = 0;
    for (int i = 20; i >= 0; --i)
    {
        int c = x >> i & 1;
        if (!tr[p][c])
            tr[p][c] = ++tot;
        p = tr[p][c];
    }
}

int query(int x)
{
    int p = 0, res = 0;
    for (int i = 20; i >= 0; --i)
    {
        int c = x >> i & 1;
        if (tr[p][!c])
        {
            p = tr[p][!c];
            res += 1 << i;
        }
        else
            p = tr[p][c];
    }
    return res;
}

map<int, int> mp;

void solve()
{
    int n, l, r;
    cin >> n;
    insert(0);
    mp[0] = 0;
    int ans = -1;
    for (int i = 1;i <= n; ++i){
        cin >> a[i];
        s[i] = s[i - 1] ^ a[i];
        insert(s[i]);
        int tmp = query(s[i]);
        if (tmp > ans){
            ans = tmp;
            r = i;
            l = mp[tmp ^ s[i]] + 1;
        }
        mp[s[i]] = i;
    }
    cout << ans << " " << l << " " << r << endl;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

+ Border1

给一个长度为n的仅包含小写字母的字符串S，一个正整数k，求一个最长的字符串T，满足:
1. T为S的前缀
2. T为S的后缀
3. T在S中至少出现k次

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j, k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 10;
const ll mod  = 998244353;
const ll inf  = 0x3f3f3f3f;

vi G[maxn];
int sz[maxn];

vector<int> prefix_function(string s)
{
	G[0].push_back(1);
    int n = (int) s.length();
    vector<int> pi(n);
    for(int i = 2; i < n; i++) {
        pi[i] = pi[i - 1];
        while(pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
        G[pi[i]].push_back(i);
    }
    return pi;
}

void dfs(int u)
{
	int sum = 1;
	for (auto v : G[u]){
		dfs(v);
		sum += sz[v];
	}
	sz[u] = sum;
}

void solve()
{
	int n, k;
	cin >> n >> k;
	string s;
	cin >> s;
	s = " " + s;
	auto nxt = prefix_function(s);
	dfs(0);
	int u = n;
	while (u && sz[u] < k) u = nxt[u];
	if (!u) cout << -1 << endl;
	else cout << s.substr(1, u) << endl;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
```
+ Border2

给一个长度为n的仅包含小写字母的字符串S，有Q次操作：
1. 修改操作：1 ch 表示向字符串末尾添加一个字符ch
2. 查询操作：2 k ，求一个最长的字符串T满足：T为S的前缀，T为S的后缀，且 T在S中至少出现次

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j, k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 5e5 + 10;
const ll mod  = 998244353;
const ll inf  = 0x3f3f3f3f;

vi G[maxn];
int tr[maxn], dfn[maxn], low[maxn], f[maxn][21], tot = 0;

int lowbit(int x)
{
    return x & (-x);
}

vector<pair<int, int>> qry(maxn);

void add(int x, int val)
{
    for(int i = x; i <= tot; i += lowbit(i))
        tr[i] += val;
}
int query(int x)
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i))
        res += tr[i];
    return res;
}

vector<int> prefix_function(string s)
{
    G[0].push_back(1);
    int n = (int) s.length();
    vector<int> pi(n);
    for(int i = 2; i < n; i++) {
        pi[i] = pi[i - 1];
        while(pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
        G[pi[i]].push_back(i);
    }
    return pi;
}

void dfs(int u)
{
    dfn[u] = ++tot;
    for(auto v : G[u]) {
        f[v][0] = u;
        for(int i = 1; i <= 20; ++i)
            f[v][i] = f[f[v][i - 1]][i - 1];
        dfs(v);
    }
    low[u] = tot;
}

void solve()
{
    int n, q;
    string s;
    cin >> n >> q >> s;
    s = " " + s;
    for(int i = 1; i <= q; ++i) {
        cin >> qry[i].x;
        if(qry[i].x == 2)
            cin >> qry[i].y;
        else {
            char ch;
            cin >> ch;
            qry[i].y = ch;
            s += ch;
        }
    }
    auto nxt = prefix_function(s);
    dfs(0);
    for(int i = 1; i <= n; ++i)
        add(dfn[i], 1);
    for(int i = 1; i <= q; ++i) {
        if(qry[i].x == 1)
            add(dfn[++n], 1);
        else {
            int cur = n;
            for(int j = 20; j >= 0; --j) {
                int k = qry[i].y;
                int p = f[cur][j];
                if(query(low[p]) - query(dfn[p] - 1) < k)
                    cur = p;
            }
            int ans = -1;
            if(f[cur][0])
                ans = f[cur][0];
            cout << ans << endl;
        }
    }
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
```
