# 字符串

## 字符串哈希

+ 取双模

```cpp
#include<bits/stdc++.h>
#include<unordered_map>
#define debug cout << "debug---  "
#define debug_ cout << "\n---debug---\n"
#define oper(a) operator<(const a& ee)const
#define forr(a,b,c) for(int a=b;a<=c;a++)
#define mem(a,b) memset(a,b,sizeof a)
#define cinios (ios::sync_with_stdio(false),cin.tie(0),cout.tie(0))
#define all(a) a.begin(),a.end()
#define sz(a) (int)a.size()
#define endl "\n"
#define ul (u << 1)
#define ur (u << 1 | 1)
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
typedef pair<ll, int> PII;

const int N = 1e5 + 10, M = 2e6 + 10, mod = 1e9 + 7;
int INF = 0x3f3f3f3f; ll LNF = 0x3f3f3f3f3f3f3f3f;
int n, m, B = 10, ki;

const int mod1 = 1e9 + 9;

ll p1[N], P1 = 131, p2[N], P2 = 13331;
ll h[N], h2[N];
//乘法开ll，mod取int

int get1(int l, int r) {
    return (h[r] - (h[l - 1] * p1[r - l + 1]) % mod + mod) % mod;
}
int get2(int l, int r) {
    return (h2[r] - (h2[l - 1] * p2[r - l + 1]) % mod1 + mod1) % mod1;
}

char str[N];

void solve() {
    cin >> n >> m;
    cin >> str + 1;

    p1[0] = p2[0] = 1;

    for (int i = 1; i <= n; i++) {
        p1[i] = (p1[i - 1] * P1) % mod;
        p2[i] = (p2[i - 1] * P2) % mod1;

        h[i] = ((h[i - 1] * P1) % mod + str[i] - '0' + 1) % mod;
        h2[i] = ((h2[i - 1] * P2) % mod1 + str[i] - '0' + 1) % mod1;
    }

    while (m--)
    {
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if (get1(l1, r1) == get1(l2, r2) && get2(l1, r1) == get2(l2, r2)) cout << "Yes\n";
        else cout << "No\n";
    }
}

signed main() {
    cinios;
    int T = 1;
    for (int t = 1; t <= T; t++) {
        solve();
    }
    return 0;
}
```
## KMP

+ KMP模板

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

vector<int> prefix_function(string s)
{
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 2; i < n; i++)
    {
        pi[i] = pi[i - 1];
        while (pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
    }
    return pi;
}

int main(void)
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    string s1, s2;
    cin >> s1 >> s2;
    s1 = " " + s1;
    s2 = " " + s2;
    auto nxt = prefix_function(s2);
    for (int i = 1, j = 0; i < s1.size(); i++)
    {
        while (j && s1[i] != s2[j + 1])
            j = nxt[j];
        if (s1[i] == s2[j + 1])
            j++;
        if (j == s2.size() - 1)
        {
            cout << i - j + 1 << "\n";
            j = nxt[j];
        }
    }
    for (int i = 1; i < s2.size(); i++)
        cout << nxt[i] << " ";

    return 0;
}
```

+ carpet(二维KMP)有一个n*m的地毯，aij表示地毯每格的元素，bij表示地毯每格的价格，要求选取一块价格最大值最小的地毯，并且这块地毯无限铺开之后，原地毯是其子矩阵

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define x first
#define y second
#define int ll
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

vector<int> prefix_function(string s)
{
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 2; i < n; i++)
    {
        pi[i] = pi[i - 1];
        while (pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
    }
    return pi;
}

int get_length(vector<string> s)
{
    int len = s[1].size() - 1;
    int ret = len;
    vector<int> cnt(len + 1);
    for (int i = 1; i < s.size(); ++i)
    {
        string tmp = s[i];
        auto nxt = prefix_function(tmp);
        int j = len;
        while (j)
        {
            cnt[len - nxt[j]]++;
            j = nxt[j];
        }
    }
    for (int i = 1; i <= len; ++i)
        if (cnt[i] == s.size() - 1)
        {
            ret = i;
            break;
        }
    return ret;
}

void solve()
{
    int n, m;
    cin >> n >> m;
    vector<string> s1(n + 1);
    for (int i = 1; i <= n; ++i)
        cin >> s1[i], s1[i] = " " + s1[i];
    vector<string> s2(m + 1);
    for (int i = 1; i <= m; ++i)
    {
        string tmp = " ";
        for (int j = 1; j <= n; ++j)
            tmp += s1[j][i];
        s2[i] = tmp;
    }
    vector<vector<int>> a(n + 1, vector<int>(m + 1, 0));
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            cin >> a[i][j];
    int p = get_length(s1), q = get_length(s2);
    ll ans = 1e9;
    deque<int> dq;
    auto b = a;
    for (int i = 1; i <= n; ++i){
        while (dq.size()) dq.pop_back();
        for (int j = 1; j <= m; ++j){
            while (dq.size() && j - dq.front() + 1 > p) dq.pop_front();
            while (dq.size() && a[i][dq.back()] <= a[i][j]) dq.pop_back();
            dq.push_back(j);
            b[i][j] = a[i][dq.front()];
        }
    }
    for (int j = 1; j <= m; ++j){
        while (dq.size()) dq.pop_back();
        for (int i = 1; i <= n; ++i){
            while (dq.size() && i - dq.front() + 1 > q) dq.pop_front();
            while (dq.size() && b[dq.back()][j] <= b[i][j]) dq.pop_back();
            dq.push_back(i);
            if (i >= q && j >= p)
                ans = min(ans, 1ll * b[dq.front()][j]);
        }
    }
    ans = ans * (p + 1) * (q + 1);
    cout << ans << endl;
}

signed main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}

```

## Trie

+ trie & topo

可自定字符间大小关系，求多少个串可以成为字典序最小的串

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define x first
#define y second
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 3e4 + 10, maxm = (3e4 + 10) * 26;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int tr[maxm][26], idx = 0;
bool vis[maxm];
vector<int> edge[26];
int in[26];

void insert(string s)
{
    int x = 0;
    for (auto op : s)
    {
        auto c = op - 'a';
        if (!tr[x][c])
            tr[x][c] = ++idx;
        x = tr[x][c];
    }
    vis[x] = 1;
}

bool query(string s)
{
    auto topo = [&](){
        queue<int> q;
        int cnt = 0;
        for (int i = 0; i < 26; ++i) if (!in[i]) q.push(i);
        while(!q.empty()){
            auto op = q.front();
            q.pop(), cnt++;
            for (auto v : edge[op]){
                if (!--in[v]) q.push(v);
            }
        }
        return cnt == 26;
    };

    int x = 0;
    for (int i = 0; i < s.size(); ++i){
        auto c = s[i] - 'a';
        for (int j = 0; j < 26; ++j){
            if (j == c || !tr[x][j]) continue;
            edge[c].push_back(j);
            in[j]++;
        }
        x = tr[x][c];
        if (vis[x] && i != s.size() - 1) return false;
    }
    return topo();
}

void solve()
{
    int n;
    cin >> n;
    vector<string> v(n + 1);
    for (int i = 1; i <= n; ++i)
    {
        cin >> v[i];
        insert(v[i]);
    }
    vector<string> res;
    for (int op = 1; op <= n; ++op)
    {
        for (int i = 0; i < 26; ++i)
            in[i] = 0, edge[i].clear();
        if (query(v[op]))
            res.push_back(v[op]);
    }
    cout << res.size() << endl;
    for (auto s : res)
        cout << s << endl;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

## 01Trie

+ 两数最大异或和

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll maxm = maxn * 32;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int tr[maxm][2], idx, n;

void insert(int x){
    int p = 0;
    for (int i = 31; i >= 0; --i){
        int c = x >> i & 1;
        if (!tr[p][c]) tr[p][c] = ++idx;
        p = tr[p][c];
    }
}

int query(int x){
    int res = 0, p = 0;
    for (int i = 31; i >= 0; --i){
        int c = x >> i & 1;
        if (tr[p][c ^ 1]){
            p = tr[p][c ^ 1];
            res += 1 << i;
        }else
            p = tr[p][c];
    }
    return res;
}

void solve(){
    cin >> n;
    int ans = 0;
    for (int i = 0; i < n; ++i){
        int x; cin >> x;
        ans = max(ans, query(x));
        insert(x);
    }
    cout << ans << endl;
}

int main(){
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```

+ 区间异或最大值

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll maxm = maxn * 21;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int a[maxn], s[maxn];
int tr[maxm][2], tot;

void insert(int x)
{
    int p = 0;
    for (int i = 20; i >= 0; --i)
    {
        int c = x >> i & 1;
        if (!tr[p][c])
            tr[p][c] = ++tot;
        p = tr[p][c];
    }
}

int query(int x)
{
    int p = 0, res = 0;
    for (int i = 20; i >= 0; --i)
    {
        int c = x >> i & 1;
        if (tr[p][!c])
        {
            p = tr[p][!c];
            res += 1 << i;
        }
        else
            p = tr[p][c];
    }
    return res;
}

map<int, int> mp;

void solve()
{
    int n, l, r;
    cin >> n;
    insert(0);
    mp[0] = 0;
    int ans = -1;
    for (int i = 1;i <= n; ++i){
        cin >> a[i];
        s[i] = s[i - 1] ^ a[i];
        insert(s[i]);
        int tmp = query(s[i]);
        if (tmp > ans){
            ans = tmp;
            r = i;
            l = mp[tmp ^ s[i]] + 1;
        }
        mp[s[i]] = i;
    }
    cout << ans << " " << l << " " << r << endl;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

+ Border1

给一个长度为n的仅包含小写字母的字符串S，一个正整数k，求一个最长的字符串T，满足:
1. T为S的前缀
2. T为S的后缀
3. T在S中至少出现k次

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j, k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 10;
const ll mod  = 998244353;
const ll inf  = 0x3f3f3f3f;

vi G[maxn];
int sz[maxn];

vector<int> prefix_function(string s)
{
	G[0].push_back(1);
    int n = (int) s.length();
    vector<int> pi(n);
    for(int i = 2; i < n; i++) {
        pi[i] = pi[i - 1];
        while(pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
        G[pi[i]].push_back(i);
    }
    return pi;
}

void dfs(int u)
{
	int sum = 1;
	for (auto v : G[u]){
		dfs(v);
		sum += sz[v];
	}
	sz[u] = sum;
}

void solve()
{
	int n, k;
	cin >> n >> k;
	string s;
	cin >> s;
	s = " " + s;
	auto nxt = prefix_function(s);
	dfs(0);
	int u = n;
	while (u && sz[u] < k) u = nxt[u];
	if (!u) cout << -1 << endl;
	else cout << s.substr(1, u) << endl;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
```
+ Border2

给一个长度为n的仅包含小写字母的字符串S，有Q次操作：
1. 修改操作：1 ch 表示向字符串末尾添加一个字符ch
2. 查询操作：2 k ，求一个最长的字符串T满足：T为S的前缀，T为S的后缀，且 T在S中至少出现次

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j, k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 5e5 + 10;
const ll mod  = 998244353;
const ll inf  = 0x3f3f3f3f;

vi G[maxn];
int tr[maxn], dfn[maxn], low[maxn], f[maxn][21], tot = 0;

int lowbit(int x)
{
    return x & (-x);
}

vector<pair<int, int>> qry(maxn);

void add(int x, int val)
{
    for(int i = x; i <= tot; i += lowbit(i))
        tr[i] += val;
}
int query(int x)
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i))
        res += tr[i];
    return res;
}

vector<int> prefix_function(string s)
{
    G[0].push_back(1);
    int n = (int) s.length();
    vector<int> pi(n);
    for(int i = 2; i < n; i++) {
        pi[i] = pi[i - 1];
        while(pi[i] && s[i] != s[pi[i] + 1])
            pi[i] = pi[pi[i]];
        pi[i] += (s[i] == s[pi[i] + 1]);
        G[pi[i]].push_back(i);
    }
    return pi;
}

void dfs(int u)
{
    dfn[u] = ++tot;
    for(auto v : G[u]) {
        f[v][0] = u;
        for(int i = 1; i <= 20; ++i)
            f[v][i] = f[f[v][i - 1]][i - 1];
        dfs(v);
    }
    low[u] = tot;
}

void solve()
{
    int n, q;
    string s;
    cin >> n >> q >> s;
    s = " " + s;
    for(int i = 1; i <= q; ++i) {
        cin >> qry[i].x;
        if(qry[i].x == 2)
            cin >> qry[i].y;
        else {
            char ch;
            cin >> ch;
            qry[i].y = ch;
            s += ch;
        }
    }
    auto nxt = prefix_function(s);
    dfs(0);
    for(int i = 1; i <= n; ++i)
        add(dfn[i], 1);
    for(int i = 1; i <= q; ++i) {
        if(qry[i].x == 1)
            add(dfn[++n], 1);
        else {
            int cur = n;
            for(int j = 20; j >= 0; --j) {
                int k = qry[i].y;
                int p = f[cur][j];
                if(query(low[p]) - query(dfn[p] - 1) < k)
                    cur = p;
            }
            int ans = -1;
            if(f[cur][0])
                ans = f[cur][0];
            cout << ans << endl;
        }
    }
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
```

## ACAM

+ AC自动机模板

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j, k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 2e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int tr[maxn][26], cnt = 0;
int sz[maxn], id[maxn], fail[maxn];
vi G[maxn];
string s;

void insert(int x)
{
    int p = 0;
    for(int i = 0; i < s.size(); ++i) {
        int c = s[i] - 'a';
        if(!tr[p][c])
            tr[p][c] = ++cnt;
        p = tr[p][c];
    }
    id[x] = p;
}

void build()
{
    queue<int> q;
    for(int i = 0; i < 26; ++i)
        if(tr[0][i])
            q.push(tr[0][i]);
    while(q.size()) {
        int u = q.front();
        q.pop();
        for(int i = 0; i < 26; ++i) {
            int &v = tr[u][i];
            if(v) {
                fail[v] = tr[fail[u]][i];
                q.push(tr[u][i]);
            }
            else
                v = tr[fail[u]][i];
        }
    }
}

void dfs(int u)
{
    for(auto v : G[u]) {
    	dfs(v);
        sz[u] += sz[v];
    }
}

void solve()
{
    int n;
    cin >> n;
    for(int i = 1; i <= n; ++i) {
        cin >> s;
        insert(i);
    }
    build();
    cin >> s;
    int p = 0;
    for(auto c : s) {
        p = tr[p][c - 'a'];
        sz[p]++;
    }
    for(int i = 1; i <= cnt; ++i)
        G[fail[i]].push_back(i);
    dfs(0);
    for(int i = 1; i <= n; ++i)
        cout << sz[id[i]] << endl;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
```

+ 单词(出现了多少次)

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

int tr[maxn][26], cnt = 0;
int sz[maxn], id[maxn], fail[maxn], ed[maxn], ans[maxn];
vi G[maxn];
string s;

void insert(int x)
{
	int p = 0;
	for (int i = 0; i < s.size(); ++i) {
		int c = s[i] - 'a';
		if (!tr[p][c])
			tr[p][c] = ++cnt;
		p = tr[p][c];
		sz[p]++;
	}
	id[x] = p;
	ed[p] = s.size();
}

void build()
{
	queue<int> q;
	for (int i = 0; i < 26; ++i)
		if (tr[0][i])
			q.push(tr[0][i]);
	while (q.size()) {
		int u = q.front();
		q.pop();
		for (int i = 0; i < 26; ++i) {
			int &v = tr[u][i];
			if (v) {
				fail[v] = tr[fail[u]][i];
				q.push(tr[u][i]);
			}
			else
				v = tr[fail[u]][i];
		}
	}
}

void dfs(int u)
{
    for(auto v : G[u]) {
    	dfs(v);
        sz[u] += sz[v];
    }
}

void solve() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> s;
		insert(i);
	}
	build();
	for (int i = 1; i <= cnt; ++i)
		G[fail[i]].push_back(i);
	dfs(0);
	for (int i = 1; i <= n; ++i)
		cout << sz[id[i]] << endl;
}

int main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```

+ 文本生成器

长度为n的串中，出现任一所给字符串的个数的方案书

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 4e6 + 10;
const ll mod = 10007;
const ll inf = 0x3f3f3f3f;

int tr[maxn][26], tot;
int fail[maxn];
vi G[maxn];
int ok[maxn];
int f[10010][6010];

void insert(string s)
{
    int p = 0;
    for (int i = 0; i < s.size(); ++i)
    {
        int c = s[i] - 'A';
        if (!tr[p][c])
            tr[p][c] = ++tot;
        p = tr[p][c];
    }
    ok[p] = 1;
}

void build()
{
    queue<int> q;
    for (int i = 0; i < 26; ++i)
        if (tr[0][i])
            q.push(tr[0][i]);
    while (!q.empty())
    {
        auto u = q.front();
        q.pop();
        for (int i = 0; i < 26; ++i){
            auto &v = tr[u][i];
            if (v){
                fail[v] = tr[fail[u]][i];
                q.push(v);
            }else
                v = tr[fail[u]][i];
        }
    }
}

void dfs(int u){
    for (auto v : G[u]){
        if (ok[u]) ok[v] = 1;
        dfs(v);
    }
}

void solve()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i){
        string s;
        cin >> s;
        insert(s);
    }
    build();
    for (int i = 1; i <= tot; ++i) G[fail[i]].push_back(i);
    dfs(0);
    f[0][0] = 1;
    for (int i = 0; i <= m; ++i){
        for (int j = 0; j <= tot; ++j){
            for (int k = 0; k < 26; ++k){
                if (!ok[tr[j][k]]) f[i + 1][tr[j][k]] = (f[i + 1][tr[j][k]] + f[i][j]) % mod;
            }
        }
    }
    ll ans = 0;
    for (int i = 0; i <= tot; ++i)
        if (!ok[i]) ans += f[m][i];
    ll sum = 1;
    for (int i = 1; i <= m; ++i)
        sum = sum * 26 % mod;
    cout << ((sum - ans) % mod + mod) % mod;
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    // cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

## manacher

+ 查回文

给出l, r求l, r区间内满足点对下字符串为回文串的方案点对数

位于左半个区间的回文中心，在延伸的过程中只可能被区间的左边界截断，位于右半个区间的，只可能被区间的右边界截断。
对于每个i，我给区间[i − r[i] + 1, i]这些位置加一，然后我要求的东西就转化成了区间[l, +∞)的

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define iinf 0x3f3f3f3f
#define linf (1ll << 60)
#define rep(i, j, k) for (int i = (j); i <= (k); i++)
#define per(i, j, k) for (int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 4e5 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

struct Manacher
{
    int r[maxn], p[maxn], n;
    void clear() { memset(r, 0, sizeof r), memset(p, 0, sizeof p); }
    void calc(string s, int N)
    {
        n = N;
        int i, j, mx(0), center;
        r[0] = -2;
        for (i = 1; i <= N; i++)
            r[2 * i] = s[i];
        for (i = 1; i <= N; i++)
            r[2 * i - 1] = -1;
        r[2 * N + 1] = -1;
        for (i = 1; i <= 2 * N + 1; i++)
        {
            if (mx >= i)
                p[i] = min(p[2 * center - i], mx - i + 1);
            else
                p[i] = 1;
            while (r[i - p[i]] == r[i + p[i]])
                p[i]++;
            if (i + p[i] - 1 > mx)
            {
                mx = i + p[i] - 1;
                center = i;
            }
        }
    }
} mnc;
ll n, id[maxn], l[maxn], r[maxn], ans[maxn], q;
struct SegmentTree
{
    ll mn[maxn << 2], mx[maxn << 2], sum[maxn << 2], add[maxn << 2], set[maxn << 2], L[maxn << 2], R[maxn << 2];
    void maketag_set(ll o, ll v)
    {
        add[o] = 0;
        set[o] = v;
        mx[o] = mn[o] = v;
        sum[o] = (R[o] - L[o] + 1) * v;
    }
    void maketag_add(ll o, ll v)
    {
        add[o] += v;
        mx[o] += v, mn[o] += v;
        sum[o] += (R[o] - L[o] + 1) * v;
    }
    void pushdown(ll o)
    {
        if (L[o] == R[o])
            return;
        if (~set[o])
        {
            maketag_set(o << 1, set[o]);
            maketag_set(o << 1 | 1, set[o]);
            set[o] = -1;
        }
        if (add[o])
        {
            maketag_add(o << 1, add[o]);
            maketag_add(o << 1 | 1, add[o]);
            add[o] = 0;
        }
    }
    void pushup(ll o)
    {
        mx[o] = max(mx[o << 1], mx[o << 1 | 1]);
        mn[o] = min(mn[o << 1], mn[o << 1 | 1]);
        sum[o] = sum[o << 1] + sum[o << 1 | 1];
    }
    void build(ll o, ll l, ll r, ll *array = NULL)
    {
        ll mid(l + r >> 1);
        L[o] = l, R[o] = r;
        add[o] = 0;
        set[o] = -1;
        if (l == r)
        {
            if (array)
                mn[o] = mx[o] = sum[o] = array[l];
            else
                mn[o] = mx[o] = sum[o] = 0;
            return;
        }
        build(o << 1, l, mid, array);
        build(o << 1 | 1, mid + 1, r, array);
        pushup(o);
    }
    void Set(ll o, ll l, ll r, ll v)
    {
        ll mid(L[o] + R[o] >> 1);
        if (l <= L[o] and r >= R[o])
        {
            maketag_set(o, v);
            return;
        }
        pushdown(o);
        if (l <= mid)
            Set(o << 1, l, r, v);
        if (r > mid)
            Set(o << 1 | 1, l, r, v);
        pushup(o);
    }
    void Add(ll o, ll l, ll r, ll v)
    {
        ll mid(L[o] + R[o] >> 1);
        if (l <= L[o] and r >= R[o])
        {
            maketag_add(o, v);
            return;
        }
        pushdown(o);
        if (l <= mid)
            Add(o << 1, l, r, v);
        if (r > mid)
            Add(o << 1 | 1, l, r, v);
        pushup(o);
    }
    ll Sum(ll o, ll l, ll r)
    {
        pushdown(o);
        ll mid(L[o] + R[o] >> 1), ans(0);
        if (l <= L[o] and r >= R[o])
            return sum[o];
        if (l <= mid)
            ans += Sum(o << 1, l, r);
        if (r > mid)
            ans += Sum(o << 1 | 1, l, r);
        return ans;
    }
    ll Min(ll o, ll l, ll r)
    {
        ll mid(L[o] + R[o] >> 1), ans(linf);
        if (l <= L[o] and r >= R[o])
            return mn[o];
        pushdown(o);
        if (l <= mid)
            ans = min(ans, Min(o << 1, l, r));
        if (r > mid)
            ans = min(ans, Min(o << 1 | 1, l, r));
        return ans;
    }
    ll Max(ll o, ll l, ll r)
    {
        ll mid(L[o] + R[o] >> 1), ans(-linf);
        if (l <= L[o] and r >= R[o])
            return mx[o];
        pushdown(o);
        if (l <= mid)
            ans = max(ans, Max(o << 1, l, r));
        if (r > mid)
            ans = max(ans, Max(o << 1 | 1, l, r));
        return ans;
    }
} segtree;

void solve()
{
    cin >> n >> q;
    string s;
    cin >> s;
    s = " " + s;
    mnc.calc(s, n);
    for (int i = 1; i <= q; ++i){
        cin >> l[i] >> r[i];
        l[i] = 2 * l[i] - 1;
        r[i] = 2 * r[i] + 1;
        id[i] = i;
    }
    sort(id + 1, id + q + 1, [&](ll a, ll b){return l[a] + r[a] < l[b] + r[b];});
    segtree.build(1, 1, 2 * n + 1);
    int j = 1;
    for (int i = 1; i <= q; ++i){
        while(j <= (l[id[i]] + r[id[i]] >> 1)){
            segtree.Add(1, j - mnc.p[j] + 1, j, 1);
            ++j;
        }
        ans[id[i]] += segtree.Sum(1, l[id[i]], 2 * n);
    }
    segtree.build(1, 1, 2 * n + 1);
    j = 2 * n + 1;
    for (int i = q; i >= 1; --i){
        while (j > (l[id[i]] + r[id[i]] >> 1)){
            segtree.Add(1, j, j + mnc.p[j] - 1, 1);
            --j;
        }
        ans[id[i]] += segtree.Sum(1, 1, r[id[i]]);
    }
    for (int i = 1; i <= q; ++i){
        ans[i] -= (r[i] + 1 >> 1) - (l[i] >> 1);
        cout << ans[i] / 2 << endl;
    }
}

int main()
{
    ios;
    // freopen("sample.txt", "r", stdin);
    // freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}
```

+ 拉拉队排练

按照女生的个数降序排序之后，前K个和谐小群体的女生个数的乘积是多少。由于答案可能很大，只要你告诉她，答案除以19930726的余数是多少就行了

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define int ll
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll inf = 0x3f3f3f3f;
const int N = 2e6 + 10;
const int mod = 19930726;
string s;
int d[N];
int mp[N];

int qmi(int a, int n)
{
    int res = 1;
    a %= mod;
    while (n)
    {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

void manacher(int n)
{
    d[1] = 1;

    for (int i = 2, l, r = 1; i <= n; i++)
    {
        if (r >= i) d[i] = min(r - i + 1, d[r - i + l]); // 在加速盒子内
        while (s[i - d[i]] == s[i + d[i]]) d[i]++; // 盒外暴力
        if (i + d[i] - 1 > r) r = i + d[i] - 1, l = i - d[i] + 1; // 更新加速盒子（根据有边界）
        mp[d[i] * 2 - 1]++;
    }
}

signed main()
{
    ios;
    int n, k;
    cin >> n >> k >> s;
    s = '@' + s + '.';
    manacher(n);

    if (n % 2 == 0) n--;

    int ans = 1, sum = 0;
    for (int i = n; i > 0; i -= 2)
    {
        sum += mp[i];
        if (k < sum)
        {
            ans = ans * qmi(i, k) % mod;
            k -= sum;
            break;
        }
        else
        {
            ans = ans * qmi(i, sum) % mod;
            k -= sum;
        }

    }
    if (k > 0) cout << -1 << endl;
    else cout << ans << endl;

    return 0;
}
```

+ 最长双回文串

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
#define int ll
const ll maxn = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;

char s[maxn];
int p[maxn], L[maxn], R[maxn];
int n;
void Manacher(string t)
{
    s[0] = '@', s[1] = '#';
    int cnt = 1;
    for (auto x : t)
    {
        s[++cnt] = x;
        s[++cnt] = '#';
    }
    n = cnt;
    for (int i = 1, mid = 0, r = 0; i <= n; i++)
    {
        if (i <= r)p[i] = min(p[2 * mid - i], r - i + 1);
        while (s[i - p[i]] == s[i + p[i]])p[i]++;
        if (i + p[i] > r)r = i + p[i] - 1, mid = i;
        int l = i + p[i] - 1;
        int rr = i - p[i] + 1;
        R[rr] = max(R[rr], p[i] - 1);//以rr为回文串右端点的最长回文串
        L[l] = max(L[l], p[i] - 1);//以ll为回文串左端点的最长回文串
    }
}

void solve(){
	string t;
	cin >> t;
	n = t.length();
	Manacher(t);
	ll ans = 0;
	for (int i = 3; i <= n; i += 2) R[i] = max(R[i], R[i - 2] - 2);
	for (int i = n - 1; i >= 1; i -= 2) L[i] = max(L[i], L[i + 2] - 2);
	for (int i = 1; i <= n; i += 2) if (R[i] && L[i])ans = max(ans, 1ll * (L[i] + R[i]));
	cout << ans << endl;
}

signed main(){
    ios;
    //freopen("sample.txt", "r", stdin);
    //freopen("resout.txt", "w", stdout);
    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }
    return 0;
}
```
## pam

+ 本质不同回文字串个数

一个串的本质不同回文子串个数等于回文树的状态数(排除奇根和偶根两个状态)

+ 回文子串出现次数

(最大(回文字串出现的次数 * 回文子串的长度))

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 300000 + 5;
typedef long long ll;
namespace pam {
int sz, tot, last;
int cnt[maxn], ch[maxn][26], len[maxn], fail[maxn];
char s[maxn];

int node(int l) {  // 建立一个新节点，长度为 l
	sz++;
	memset(ch[sz], 0, sizeof(ch[sz]));
	len[sz] = l;
	fail[sz] = cnt[sz] = 0;
	return sz;
}

void clear() {  // 初始化
	sz = -1;
	last = 0;
	s[tot = 0] = '$';
	node(0);
	node(-1);
	fail[0] = 1;
}

int getfail(int x) {  // 找后缀回文
	while (s[tot - len[x] - 1] != s[tot]) x = fail[x];
	return x;
}

void insert(char c) {  // 建树
	s[++tot] = c;
	int now = getfail(last);
	if (!ch[now][c - 'a']) {
		int x = node(len[now] + 2);
		fail[x] = ch[getfail(fail[now])][c - 'a'];
		ch[now][c - 'a'] = x;
	}
	last = ch[now][c - 'a'];
	cnt[last]++;
}

ll solve() {
	ll ans = 0;
	for (int i = sz; i >= 0; i--) {
		cnt[fail[i]] += cnt[i];
	}
	for (int i = 1; i <= sz; i++) {  // 更新答案
		ans = max(ans, 1ll * len[i] * cnt[i]);
	}
	return ans;
}
}  // namespace pam

char s[maxn];

int main() {
	int n;
	cin >> n;
	pam::clear();
	scanf("%s", s + 1);
	for (int i = 1; s[i]; i++) {
		pam::insert(s[i]);
	}
	printf("%lld\n", pam::solve());
	return 0;
}
```

+ 例题(Colourful String)

子字符串不同颜色的数量的和

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define pll pair<ll, ll>
#define tll tuple<ll, ll, ll>
#define vi vector<int>
#define vl vector<ll>
#define x first
#define y second
#define rep(i, j, k) for(int i = (j); i <= (k); i++)
#define per(i, j ,k) for(int i = (j); i >= (k); i--)
#define ios ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
using namespace std;
typedef long long ll;
const ll maxn = 1e6 + 10;
const ll mod = 998244353;
const ll inf = 0x3f3f3f3f;


int n;
string s;

struct PAM
{
	int last, idx;
	vector<array<int, 26>> tr;
	vector<int> fail, len, cnt, mask;

	PAM(): last(0), idx(0) {
		fail.resize(n + 2), len.resize(n + 2), tr.resize(n + 2), mask.resize(n + 2), cnt.resize(n + 2);
	}
	int newnode(int l) { //新增一个结点，长度为l
		len[idx] = l;
		tr[idx].fill(0);
		return idx++;
	}
	void init() {
		idx = last = 0;
		newnode(0), newnode(-1); //偶根长度为0，奇根长度为-1
		s[0] = -1, fail[0] = 1; //偶根的失配边指向奇根，奇根的失配边指向偶根
	}
	int get_fail(int p, int i) {
		while (s[i - len[p] - 1] != s[i])    p = fail[p];
		return p;
	}
	void insert(int i) {
		int u = s[i] - 'a', p = get_fail(last, i);
		if (!tr[p][u]) {
			int now = newnode(len[p] + 2);
			mask[now] = mask[p] | (1 << u);
			fail[now] = tr[get_fail(fail[p], i)][u];
			tr[p][u] = now;
		}
		last = tr[p][u];
		cnt[last]++;
	}
};


void solve() {
	cin >> s;
	n = s.length();
	s = " " + s;
	PAM pam;
	pam.init();
	for (int i = 1; i <= n; ++i) pam.insert(i);
	for (int i = pam.idx - 1; ~i; --i) pam.cnt[pam.fail[i]] += pam.cnt[i];
	ll res = 0;
	for (int i = 2; i < pam.idx; ++i) res += pam.cnt[i] * __builtin_popcount(pam.mask[i]);
	cout << res << endl;
}

int main() {
	ios;
	//freopen("sample.txt", "r", stdin);
	//freopen("resout.txt", "w", stdout);
	int t = 1;
	//cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
```

## SA

+ nlog^2n(倍增法)
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1000010;

char s[N];
int n, w, sa[N], rk[N << 1], oldrk[N << 1];

// 为了防止访问 rk[i+w] 导致数组越界，开两倍数组。
// 当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。

int main() {
  int i, p;

  scanf("%s", s + 1);
  n = strlen(s + 1);
  for (i = 1; i <= n; ++i) sa[i] = i, rk[i] = s[i];

  for (w = 1; w < n; w <<= 1) {
    sort(sa + 1, sa + n + 1, [](int x, int y) {
      return rk[x] == rk[y] ? rk[x + w] < rk[y + w] : rk[x] < rk[y];
    });  // 这里用到了 lambda
    memcpy(oldrk, rk, sizeof(rk));
    // 由于计算 rk 的时候原来的 rk 会被覆盖，要先复制一份
    for (p = 0, i = 1; i <= n; ++i) {
      if (oldrk[sa[i]] == oldrk[sa[i - 1]] &&
          oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) {
        rk[sa[i]] = p;
      } else {
        rk[sa[i]] = ++p;
      }  // 若两个子串相同，它们对应的 rk 也需要相同，所以要去重
    }
  }

  for (i = 1; i <= n; ++i) printf("%d ", sa[i]);

  return 0;
}
```

+ SA-IS

```cpp
// 后缀类型
#define L_TYPE 0
#define S_TYPE 1

// 判断一个字符是否为LMS字符
inline bool is_lms_char(int *type, int x) {
    return x > 0 && type[x] == S_TYPE && type[x - 1] == L_TYPE;
}

// 判断两个LMS子串是否相同
inline bool equal_substring(int *S, int x, int y, int *type) {
    do {
        if (S[x] != S[y])
            return false;
        x++, y++;
    } while (!is_lms_char(type, x) && !is_lms_char(type, y));

    return S[x] == S[y];
}

// 诱导排序(从*型诱导到L型、从L型诱导到S型)
// 调用之前应将*型按要求放入SA中
inline void induced_sort(int *S, int *SA, int *type, int *bucket, int *lbucket,
                         int *sbucket, int n, int SIGMA) {
    for (int i = 0; i <= n; i++)
        if (SA[i] > 0 && type[SA[i] - 1] == L_TYPE)
            SA[lbucket[S[SA[i] - 1]]++] = SA[i] - 1;
    for (int i = 1; i <= SIGMA; i++)  // Reset S-type bucket
        sbucket[i] = bucket[i] - 1;
    for (int i = n; i >= 0; i--)
        if (SA[i] > 0 && type[SA[i] - 1] == S_TYPE)
            SA[sbucket[S[SA[i] - 1]]--] = SA[i] - 1;
}

// SA-IS主体
// S是输入字符串，length是字符串的长度, SIGMA是字符集的大小
static int *SAIS(int *S, int length, int SIGMA) {
    int n = length - 1;
    int *type = new int[n + 1];  // 后缀类型
    int *position = new int[n + 1];  // 记录LMS子串的起始位置
    int *name = new int[n + 1];  // 记录每个LMS子串的新名称
    int *SA = new int[n + 1];  // SA数组
    int *bucket = new int[SIGMA + 1];  // 每个字符的桶
    int *lbucket = new int[SIGMA + 1];  // 每个字符的L型桶的起始位置
    int *sbucket = new int[SIGMA + 1];  // 每个字符的S型桶的起始位置

    // 初始化每个桶
    memset(bucket, 0, sizeof(int) * (SIGMA + 1));
    for (int i = 0; i <= n; i++)
        bucket[S[i]]++;
    lbucket[0] = sbucket[0] = 0;
    for (int i = 1; i <= SIGMA; i++) {
        bucket[i] += bucket[i - 1];
        lbucket[i] = bucket[i - 1];
        sbucket[i] = bucket[i] - 1;
    }

    // 确定后缀类型(利用引理2.1)
    type[n] = S_TYPE;
    for (int i = n - 1; i >= 0; i--) {
        if (S[i] < S[i + 1])
            type[i] = S_TYPE;
        else if (S[i] > S[i + 1])
            type[i] = L_TYPE;
        else
            type[i] = type[i + 1];
    }

    // 寻找每个LMS子串
    int cnt = 0;
    for (int i = 1; i <= n; i++)
        if (type[i] == S_TYPE && type[i - 1] == L_TYPE)
            position[cnt++] = i;

    // 对LMS子串进行排序
    fill(SA, SA + n + 1, -1);
    for (int i = 0; i < cnt; i++)
        SA[sbucket[S[position[i]]]--] = position[i];
    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);

    // 为每个LMS子串命名
    fill(name, name + n + 1, -1);
    int lastx = -1, namecnt = 1;  // 上一次处理的LMS子串与名称的计数
    bool flag = false;  // 这里顺便记录是否有重复的字符
    for (int i = 1; i <= n; i++) {
        int x = SA[i];

        if (is_lms_char(type, x)) {
            if (lastx >= 0 && !equal_substring(S, x, lastx, type))
                namecnt++;
            // 因为只有相同的LMS子串才会有同样的名称
            if (lastx >= 0 && namecnt == name[lastx])
                flag = true;

            name[x] = namecnt;
            lastx = x;
        }
    }  // for
    name[n] = 0;

    // 生成S1
    int *S1 = new int[cnt];
    int pos = 0;
    for (int i = 0; i <= n; i++)
        if (name[i] >= 0)
            S1[pos++] = name[i];

    int *SA1;
    if (!flag) {
        // 直接计算SA1
        SA1 = new int[cnt + 1];

        for (int i = 0; i < cnt; i++)
            SA1[S1[i]] = i;
    } else
        SA1 = SAIS(S1, cnt, namecnt);  // 递归计算SA1

    // 从SA1诱导到SA
    lbucket[0] = sbucket[0] = 0;
    for (int i = 1; i <= SIGMA; i++) {
        lbucket[i] = bucket[i - 1];
        sbucket[i] = bucket[i] - 1;
    }
    fill(SA, SA + n + 1, -1);
    for (int i = cnt - 1; i >= 0; i--)  // 这里是逆序扫描SA1，因为SA中S型桶是倒序的
        SA[sbucket[S[position[SA1[i]]]]--] = position[SA1[i]];
    induced_sort(S, SA, type, bucket, lbucket, sbucket, n, SIGMA);

    // 后缀数组计算完毕
    return SA;
}
```

+ 从字符串首尾取字符最小化字典序

暴力做法就是每次最坏 O(n) 地判断当前应该取首还是尾（即比较取首得到的字符串与取尾得到的反串的大小），只需优化这一判断过程即可。
由于需要在原串后缀与反串后缀构成的集合内比较大小，可以将反串拼接在原串后，并在中间加上一个没出现过的字符（如 #，代码中可以直接使用空字符），求后缀数组，即可 O(1) 完成这一判断。

```cpp
#include <cctype>
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1000010;

char s[N];
int n, sa[N], id[N], oldrk[N * 2], rk[N * 2], px[N], cnt[N];

bool cmp(int x, int y, int w) {
  return oldrk[x] == oldrk[y] && oldrk[x + w] == oldrk[y + w];
}

int main() {
  int i, w, m = 200, p, l = 1, r, tot = 0;

  cin >> n;
  r = n;

  for (i = 1; i <= n; ++i)
    while (!isalpha(s[i] = getchar()))
      ;
  for (i = 1; i <= n; ++i)
    rk[i] = rk[2 * n + 2 - i] = s[i];  // 拼接正反两个字符串，中间空出一个字符

  n = 2 * n + 1;
  // 求后缀数组
  for (i = 1; i <= n; ++i) ++cnt[rk[i]];
  for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
  for (i = n; i >= 1; --i) sa[cnt[rk[i]]--] = i;

  for (w = 1; w < n; w *= 2, m = p) {  // m=p 就是优化计数排序值域
    for (p = 0, i = n; i > n - w; --i) id[++p] = i;
    for (i = 1; i <= n; ++i)
      if (sa[i] > w) id[++p] = sa[i] - w;
    memset(cnt, 0, sizeof(cnt));
    for (i = 1; i <= n; ++i) ++cnt[px[i] = rk[id[i]]];
    for (i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
    for (i = n; i >= 1; --i) sa[cnt[px[i]]--] = id[i];
    memcpy(oldrk, rk, sizeof(rk));
    for (p = 0, i = 1; i <= n; ++i)
      rk[sa[i]] = cmp(sa[i], sa[i - 1], w) ? p : ++p;
  }
  // 利用后缀数组O(1)进行判断
  while (l <= r) {
    printf("%c", rk[l] < rk[n + 1 - r] ? s[l++] : s[r--]);
    if ((++tot) % 80 == 0) puts("");  // 回车
  }

  return 0;
}
```
